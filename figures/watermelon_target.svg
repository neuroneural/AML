<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   viewBox="0 0 682.87842 379.24414"
   height="379.24414"
   width="682.87842"
   id="svg1275"
   version="1.1"
   sodipodi:docname="watermelon_target.svg"
   inkscape:version="1.3 (0e150ed, 2023-07-21)"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:ns1="https://launchpad.net/jessyink">
  <sodipodi:namedview
     fit-margin-bottom="0"
     fit-margin-right="0"
     fit-margin-left="0"
     fit-margin-top="0"
     pagecolor="#ffffff"
     bordercolor="#666666"
     inkscape:document-rotation="0"
     borderopacity="1"
     objecttolerance="10"
     gridtolerance="10"
     guidetolerance="10"
     inkscape:pageopacity="0"
     inkscape:pageshadow="2"
     inkscape:window-width="1512"
     inkscape:window-height="916"
     id="namedview2415"
     showgrid="false"
     inkscape:zoom="1.3387051"
     inkscape:cx="324.19388"
     inkscape:cy="205.79588"
     inkscape:window-x="0"
     inkscape:window-y="38"
     inkscape:window-maximized="1"
     inkscape:current-layer="layer3"
     inkscape:showpageshadow="2"
     inkscape:pagecheckerboard="0"
     inkscape:deskcolor="#d1d1d1" />
  <metadata
     id="metadata1281">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title />
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <defs
     id="defs1279">
    <marker
       style="overflow:visible"
       id="Arrow1Lend"
       refX="0"
       refY="0"
       orient="auto">
      <path
         inkscape:connector-curvature="0"
         transform="matrix(-0.8,0,0,-0.8,-10,0)"
         style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1pt;stroke-opacity:1"
         d="M 0,0 5,-5 -12.5,0 5,5 Z"
         id="path1614" />
    </marker>
  </defs>
  <text
     xml:space="preserve"
     style="font-style:normal;font-weight:normal;font-size:29.3333px;line-height:1.25;font-family:sans-serif;display:inline;fill:#000000;fill-opacity:1;stroke:none"
     x="35.450172"
     y="22.429661"
     id="text1326"
     ns1:effectIn="name:appear;order:3;length:800"><tspan
       id="tspan1324"
       x="35.450172"
       y="22.429661">10% of radius</tspan></text>
  <g
     transform="matrix(1.0022031,0,0,1.0022031,-75.802494,-15.573044)"
     id="g3118">
    <g
       id="g3012">
      <rect
         style="display:inline;fill:#008000;fill-opacity:0.983871;stroke:#008000;stroke-width:0.855483"
         id="rect1307"
         width="278.52899"
         height="25.105536"
         x="76.063599"
         y="54.332401" />
      <rect
         y="54.001057"
         x="97.178467"
         height="25.779711"
         width="13.776428"
         id="rect1307-2"
         style="display:inline;fill:#ff0000;fill-opacity:0.983871;stroke:#ff0000;stroke-width:0.192796" />
    </g>
    <rect
       style="display:inline;fill:#008000;fill-opacity:0.983871;stroke:#008000;stroke-width:0.855483"
       id="rect1307-3"
       width="278.52899"
       height="25.105536"
       x="76.063599"
       y="106.80261" />
    <rect
       y="106.47137"
       x="206.17857"
       height="25.779499"
       width="13.806991"
       id="rect1307-2-9"
       style="display:inline;fill:#ff0000;fill-opacity:0.983871;stroke:#ff0000;stroke-width:0.193009" />
    <rect
       style="display:inline;fill:#008000;fill-opacity:0.983871;stroke:#008000;stroke-width:0.855483"
       id="rect1307-37"
       width="278.52899"
       height="25.105536"
       x="76.063599"
       y="159.27283" />
    <rect
       y="158.94159"
       x="144.17857"
       height="25.779499"
       width="13.806991"
       id="rect1307-2-5"
       style="display:inline;fill:#ff0000;fill-opacity:0.983871;stroke:#ff0000;stroke-width:0.193009" />
    <rect
       style="display:inline;fill:#008000;fill-opacity:0.983871;stroke:#008000;stroke-width:0.855483"
       id="rect1307-21"
       width="278.52899"
       height="25.105536"
       x="76.063599"
       y="211.74303" />
    <rect
       y="211.41179"
       x="330.17859"
       height="25.779499"
       width="13.806991"
       id="rect1307-2-8"
       style="display:inline;fill:#ff0000;fill-opacity:0.983871;stroke:#ff0000;stroke-width:0.193009" />
    <rect
       style="display:inline;fill:#008000;fill-opacity:0.983871;stroke:#008000;stroke-width:0.855483"
       id="rect1307-5"
       width="278.52899"
       height="25.105536"
       x="76.063599"
       y="264.21323" />
    <rect
       y="263.88199"
       x="184.17857"
       height="25.779499"
       width="13.806991"
       id="rect1307-2-58"
       style="display:inline;fill:#ff0000;fill-opacity:0.983871;stroke:#ff0000;stroke-width:0.193009" />
    <rect
       style="display:inline;fill:#008000;fill-opacity:0.983871;stroke:#008000;stroke-width:0.855483"
       id="rect1307-6"
       width="278.52899"
       height="25.105536"
       x="76.063599"
       y="316.68344" />
    <rect
       y="316.3522"
       x="224.17857"
       height="25.779499"
       width="13.806991"
       id="rect1307-2-7"
       style="display:inline;fill:#ff0000;fill-opacity:0.983871;stroke:#ff0000;stroke-width:0.193009" />
    <rect
       style="display:inline;fill:#008000;fill-opacity:0.983871;stroke:#008000;stroke-width:0.855483"
       id="rect1307-4"
       width="278.52899"
       height="25.105536"
       x="76.063599"
       y="369.15366" />
    <rect
       y="368.82242"
       x="204.17857"
       height="25.779499"
       width="13.806991"
       id="rect1307-2-1"
       style="display:inline;fill:#ff0000;fill-opacity:0.983871;stroke:#ff0000;stroke-width:0.193009" />
  </g>
  <g
     transform="translate(-75.635857,-15.454284)"
     inkscape:groupmode="layer"
     id="layer2"
     inkscape:label="master"
     ns1:masterSlide="masterSlide" />
  <g
     transform="translate(-75.635857,-15.454284)"
     inkscape:groupmode="layer"
     id="layer3"
     inkscape:label="random"
     style="display:inline">
    <ellipse
       style="fill:#008000;fill-opacity:0.983871;stroke:#008000;stroke-width:1.06139"
       id="path1455"
       cx="618.51428"
       cy="224.30154"
       rx="139.46931"
       ry="139.4693"
       ns1:effectIn="name:appear;order:1;length:300" />
    <ellipse
       ry="6.973464"
       rx="6.9734654"
       cy="125.71897"
       cx="575.95605"
       id="path1455-5"
       style="fill:#ff0000;fill-opacity:0.983871;stroke:#008000;stroke-width:0.053069"
       ns1:effectIn="name:fade;order:1;length:800"
       ns1:effectOut="name:fade;order:2;length:800" />
    <text
       ns1:effectIn="name:appear;order:10;length:300"
       id="text1326-9"
       y="37.883945"
       x="535.64917"
       style="font-style:normal;font-weight:normal;font-size:29.3333px;line-height:1.25;font-family:sans-serif;display:inline;fill:#000000;fill-opacity:1;stroke:none"
       xml:space="preserve"><tspan
         y="37.883945"
         x="535.64917"
         id="tspan1324-8">1% of area</tspan></text>
    <ellipse
       style="fill:#ff0000;fill-opacity:0.983871;stroke:#008000;stroke-width:0.053069"
       id="path1455-5-4"
       cx="667.80951"
       cy="171.06084"
       rx="6.9734654"
       ry="6.973464"
       ns1:effectIn="name:fade;order:6;length:800"
       ns1:effectOut="name:fade;order:7;length:800" />
    <ellipse
       style="fill:#ff0000;fill-opacity:0.983871;stroke:#008000;stroke-width:0.053069"
       id="path1455-5-0"
       cx="549.03802"
       cy="230.82007"
       rx="6.9734654"
       ry="6.973464"
       ns1:effectIn="name:fade;order:5;length:800"
       ns1:effectOut="name:fade;order:6;length:800" />
    <ellipse
       style="fill:#ff0000;fill-opacity:0.983871;stroke:#008000;stroke-width:0.053069"
       id="path1455-5-5"
       cx="658.09863"
       cy="298.04922"
       rx="6.9734654"
       ry="6.973464"
       ns1:effectIn="name:appear;order:9;length:300" />
    <ellipse
       style="fill:#ff0000;fill-opacity:0.983871;stroke:#008000;stroke-width:0.053069"
       id="path1455-5-6"
       cx="634.94196"
       cy="250.98882"
       rx="6.9734654"
       ry="6.973464"
       ns1:effectIn="name:fade;order:2;length:800"
       ns1:effectOut="name:fade;order:3;length:800" />
    <ellipse
       style="fill:#ff0000;fill-opacity:0.983871;stroke:#008000;stroke-width:0.053069"
       id="path1455-5-8"
       cx="681.25537"
       cy="177.78375"
       rx="6.9734654"
       ry="6.973464"
       ns1:effectIn="name:fade;order:8;length:300"
       ns1:effectOut="name:fade;order:9;length:200" />
    <ellipse
       style="fill:#ff0000;fill-opacity:0.983871;stroke:#008000;stroke-width:0.053069"
       id="path1455-5-53"
       cx="625.97809"
       cy="107.56664"
       rx="6.9734654"
       ry="6.973464"
       ns1:effectIn="name:fade;order:4;length:800"
       ns1:effectOut="name:fade;order:5;length:800" />
    <ellipse
       style="fill:#ff0000;fill-opacity:0.983871;stroke:#008000;stroke-width:0.053069"
       id="path1455-5-7"
       cx="564.72485"
       cy="293.56729"
       rx="6.9734654"
       ry="6.973464"
       ns1:effectIn="name:fade;order:7;length:300"
       ns1:effectOut="name:fade;order:8;length:200" />
  </g>
  <script
     id="JessyInk"
     ns1:version="1.5.5">// Copyright 2008, 2009 Hannes Hochreiner&#10;// This program is free software: you can redistribute it and/or modify&#10;// it under the terms of the GNU General Public License as published by&#10;// the Free Software Foundation, either version 3 of the License, or&#10;// (at your option) any later version.&#10;//&#10;// This program is distributed in the hope that it will be useful,&#10;// but WITHOUT ANY WARRANTY; without even the implied warranty of&#10;// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#10;// GNU General Public License for more details.&#10;//&#10;// You should have received a copy of the GNU General Public License&#10;// along with this program.  If not, see http://www.gnu.org/licenses/.&#10;&#10;// Set onload event handler.&#10;window.onload = jessyInkInit;&#10;&#10;// Creating a namespace dictionary. The standard Inkscape namespaces are taken from inkex.py.&#10;var NSS = new Object();&#10;NSS['sodipodi']='http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd';&#10;NSS['cc']='http://web.resource.org/cc/';&#10;NSS['svg']='http://www.w3.org/2000/svg';&#10;NSS['dc']='http://purl.org/dc/elements/1.1/';&#10;NSS['rdf']='http://www.w3.org/1999/02/22-rdf-syntax-ns#';&#10;NSS['inkscape']='http://www.inkscape.org/namespaces/inkscape';&#10;NSS['xlink']='http://www.w3.org/1999/xlink';&#10;NSS['xml']='http://www.w3.org/XML/1998/namespace';&#10;NSS['jessyink']='https://launchpad.net/jessyink';&#10;&#10;// Keycodes.&#10;var LEFT_KEY = 37; // cursor left keycode&#10;var UP_KEY = 38; // cursor up keycode&#10;var RIGHT_KEY = 39; // cursor right keycode&#10;var DOWN_KEY = 40; // cursor down keycode&#10;var PAGE_UP_KEY = 33; // page up keycode&#10;var PAGE_DOWN_KEY = 34; // page down keycode&#10;var HOME_KEY = 36; // home keycode&#10;var END_KEY = 35; // end keycode&#10;var ENTER_KEY = 13; // next slide&#10;var SPACE_KEY = 32;&#10;var ESCAPE_KEY = 27;&#10;&#10;// Presentation modes.&#10;var SLIDE_MODE = 1;&#10;var INDEX_MODE = 2;&#10;var DRAWING_MODE = 3;&#10;&#10;// Mouse handler actions.&#10;var MOUSE_UP = 1;&#10;var MOUSE_DOWN = 2;&#10;var MOUSE_MOVE = 3;&#10;var MOUSE_WHEEL = 4;&#10;&#10;// Parameters.&#10;var ROOT_NODE = document.getElementsByTagNameNS(NSS[&quot;svg&quot;], &quot;svg&quot;)[0];&#10;var HEIGHT = 0;&#10;var WIDTH = 0;&#10;var INDEX_COLUMNS_DEFAULT = 4;&#10;var INDEX_COLUMNS = INDEX_COLUMNS_DEFAULT;&#10;var INDEX_OFFSET = 0;&#10;var STATE_START = -1;&#10;var STATE_END = -2;&#10;var BACKGROUND_COLOR = null;&#10;var slides = new Array();&#10;&#10;// Initialisation.&#10;var currentMode = SLIDE_MODE;&#10;var masterSlide = null;&#10;var activeSlide = 0;&#10;var activeEffect = 0;&#10;var timeStep = 30; // 40 ms equal 25 frames per second.&#10;var lastFrameTime = null;&#10;var processingEffect = false;&#10;var transCounter = 0;&#10;var effectArray = 0;&#10;var defaultTransitionInDict = new Object();&#10;defaultTransitionInDict[&quot;name&quot;] = &quot;appear&quot;;&#10;var defaultTransitionOutDict = new Object();&#10;defaultTransitionOutDict[&quot;name&quot;] = &quot;appear&quot;;&#10;var jessyInkInitialised = false;&#10;&#10;// Initialise char and key code dictionaries.&#10;var charCodeDictionary = getDefaultCharCodeDictionary();&#10;var keyCodeDictionary = getDefaultKeyCodeDictionary();&#10;&#10;// Initialise mouse handler dictionary.&#10;var mouseHandlerDictionary = getDefaultMouseHandlerDictionary();&#10;&#10;var progress_bar_visible = false;&#10;var timer_elapsed = 0;&#10;var timer_start = timer_elapsed;&#10;var timer_duration = 15; // 15 minutes&#10;&#10;var history_counter = 0;&#10;var history_original_elements = new Array();&#10;var history_presentation_elements = new Array();&#10;&#10;var mouse_original_path = null;&#10;var mouse_presentation_path = null;&#10;var mouse_last_x = -1;&#10;var mouse_last_y = -1;&#10;var mouse_min_dist_sqr = 3 * 3;&#10;var path_colour = &quot;red&quot;;&#10;var path_width_default = 3;&#10;var path_width = path_width_default;&#10;var path_paint_width = path_width;&#10;&#10;var number_of_added_slides = 0;&#10;&#10;/** Initialisation function.&#10; *  The whole presentation is set-up in this function.&#10; */&#10;function jessyInkInit()&#10;{&#10;    // Make sure we only execute this code once. Double execution can occur if the onload event handler is set&#10;    // in the main svg tag as well (as was recommended in earlier versions). Executing this function twice does&#10;    // not lead to any problems, but it takes more time.&#10;    if (jessyInkInitialised)&#10;        return;&#10;&#10;    // Making the presentation scalable.&#10;    var VIEWBOX = ROOT_NODE.getAttribute(&quot;viewBox&quot;);&#10;&#10;    if (VIEWBOX)&#10;    {&#10;        WIDTH = ROOT_NODE.viewBox.animVal.width;&#10;        HEIGHT = ROOT_NODE.viewBox.animVal.height;&#10;    }&#10;    else&#10;    {&#10;        HEIGHT = parseFloat(ROOT_NODE.getAttribute(&quot;height&quot;));&#10;        WIDTH = parseFloat(ROOT_NODE.getAttribute(&quot;width&quot;));&#10;        ROOT_NODE.setAttribute(&quot;viewBox&quot;, &quot;0 0 &quot; + WIDTH + &quot; &quot; + HEIGHT);&#10;    }&#10;&#10;    ROOT_NODE.setAttribute(&quot;width&quot;, &quot;100%&quot;);&#10;    ROOT_NODE.setAttribute(&quot;height&quot;, &quot;100%&quot;);&#10;&#10;    // Setting the background color.&#10;    var namedViews = document.getElementsByTagNameNS(NSS[&quot;sodipodi&quot;], &quot;namedview&quot;);&#10;&#10;    for (var counter = 0; counter &lt; namedViews.length; counter++)&#10;    {&#10;        if (namedViews[counter].hasAttribute(&quot;id&quot;) &amp;&amp; namedViews[counter].hasAttribute(&quot;pagecolor&quot;))&#10;        {&#10;            if (namedViews[counter].getAttribute(&quot;id&quot;) == &quot;base&quot;)&#10;            {&#10;                BACKGROUND_COLOR = namedViews[counter].getAttribute(&quot;pagecolor&quot;);&#10;                var newAttribute = &quot;background-color:&quot; + BACKGROUND_COLOR + &quot;;&quot;;&#10;&#10;                if (ROOT_NODE.hasAttribute(&quot;style&quot;))&#10;                    newAttribute += ROOT_NODE.getAttribute(&quot;style&quot;);&#10;&#10;                ROOT_NODE.setAttribute(&quot;style&quot;, newAttribute);&#10;            }&#10;        }&#10;    }&#10;&#10;    // Defining clip-path.&#10;    var defsNodes = document.getElementsByTagNameNS(NSS[&quot;svg&quot;], &quot;defs&quot;);&#10;&#10;    if (defsNodes.length &gt; 0)&#10;    {&#10;        var existingClipPath = document.getElementById(&quot;jessyInkSlideClipPath&quot;);&#10;&#10;        if (!existingClipPath)&#10;        {&#10;            var rectNode = document.createElementNS(NSS[&quot;svg&quot;], &quot;rect&quot;);&#10;            var clipPath = document.createElementNS(NSS[&quot;svg&quot;], &quot;clipPath&quot;);&#10;&#10;            rectNode.setAttribute(&quot;x&quot;, 0);&#10;            rectNode.setAttribute(&quot;y&quot;, 0);&#10;            rectNode.setAttribute(&quot;width&quot;, WIDTH);&#10;            rectNode.setAttribute(&quot;height&quot;, HEIGHT);&#10;&#10;            clipPath.setAttribute(&quot;id&quot;, &quot;jessyInkSlideClipPath&quot;);&#10;            clipPath.setAttribute(&quot;clipPathUnits&quot;, &quot;userSpaceOnUse&quot;);&#10;&#10;            clipPath.appendChild(rectNode);&#10;            defsNodes[0].appendChild(clipPath);&#10;        }&#10;    }&#10;&#10;    // Making a list of the slide and finding the master slide.&#10;    var nodes = document.getElementsByTagNameNS(NSS[&quot;svg&quot;], &quot;g&quot;);&#10;    var tempSlides = new Array();&#10;    var existingJessyInkPresentationLayer = null;&#10;&#10;    for (var counter = 0; counter &lt; nodes.length; counter++)&#10;    {&#10;        if (nodes[counter].getAttributeNS(NSS[&quot;inkscape&quot;], &quot;groupmode&quot;) &amp;&amp; (nodes[counter].getAttributeNS(NSS[&quot;inkscape&quot;], &quot;groupmode&quot;) == &quot;layer&quot;))&#10;        {&#10;            if (nodes[counter].getAttributeNS(NSS[&quot;inkscape&quot;], &quot;label&quot;) &amp;&amp; nodes[counter].getAttributeNS(NSS[&quot;jessyink&quot;], &quot;masterSlide&quot;) == &quot;masterSlide&quot;)&#10;                masterSlide = nodes[counter];&#10;            else if (nodes[counter].getAttributeNS(NSS[&quot;inkscape&quot;], &quot;label&quot;) &amp;&amp; nodes[counter].getAttributeNS(NSS[&quot;jessyink&quot;], &quot;presentationLayer&quot;) == &quot;presentationLayer&quot;)&#10;                existingJessyInkPresentationLayer = nodes[counter];&#10;            else&#10;                tempSlides.push(nodes[counter].getAttribute(&quot;id&quot;));&#10;        }&#10;        else if (nodes[counter].getAttributeNS(NSS['jessyink'], 'element'))&#10;        {&#10;            handleElement(nodes[counter]);&#10;        }&#10;    }&#10;&#10;    // Hide master slide set default transitions.&#10;    if (masterSlide)&#10;    {&#10;        masterSlide.style.display = &quot;none&quot;;&#10;&#10;        if (masterSlide.hasAttributeNS(NSS[&quot;jessyink&quot;], &quot;transitionIn&quot;))&#10;            defaultTransitionInDict = propStrToDict(masterSlide.getAttributeNS(NSS[&quot;jessyink&quot;], &quot;transitionIn&quot;));&#10;&#10;        if (masterSlide.hasAttributeNS(NSS[&quot;jessyink&quot;], &quot;transitionOut&quot;))&#10;            defaultTransitionOutDict = propStrToDict(masterSlide.getAttributeNS(NSS[&quot;jessyink&quot;], &quot;transitionOut&quot;));&#10;    }&#10;&#10;    if (existingJessyInkPresentationLayer != null)&#10;    {&#10;        existingJessyInkPresentationLayer.parentNode.removeChild(existingJessyInkPresentationLayer);&#10;    }&#10;&#10;    // Set start slide.&#10;    var hashObj = new LocationHash(window.location.hash);&#10;&#10;    activeSlide = hashObj.slideNumber;&#10;    activeEffect = hashObj.effectNumber;&#10;&#10;    if (activeSlide &lt; 0)&#10;        activeSlide = 0;&#10;    else if (activeSlide &gt;= tempSlides.length)&#10;        activeSlide = tempSlides.length - 1;&#10;&#10;    var originalNode = document.getElementById(tempSlides[counter]);&#10;&#10;    var JessyInkPresentationLayer = document.createElementNS(NSS[&quot;svg&quot;], &quot;g&quot;);&#10;    JessyInkPresentationLayer.setAttributeNS(NSS[&quot;inkscape&quot;], &quot;groupmode&quot;, &quot;layer&quot;);&#10;    JessyInkPresentationLayer.setAttributeNS(NSS[&quot;inkscape&quot;], &quot;label&quot;, &quot;JessyInk Presentation Layer&quot;);&#10;    JessyInkPresentationLayer.setAttributeNS(NSS[&quot;jessyink&quot;], &quot;presentationLayer&quot;, &quot;presentationLayer&quot;);&#10;    JessyInkPresentationLayer.setAttribute(&quot;id&quot;, &quot;jessyink_presentation_layer&quot;);&#10;    JessyInkPresentationLayer.style.display = &quot;inherit&quot;;&#10;    ROOT_NODE.appendChild(JessyInkPresentationLayer);&#10;&#10;    // Gathering all the information about the transitions and effects of the slides, set the background&#10;    // from the master slide and substitute the auto-texts.&#10;    for (var counter = 0; counter &lt; tempSlides.length; counter++)&#10;    {&#10;        var originalNode = document.getElementById(tempSlides[counter]);&#10;        originalNode.style.display = &quot;none&quot;;&#10;        var node = suffixNodeIds(originalNode.cloneNode(true), &quot;_&quot; + counter);&#10;        JessyInkPresentationLayer.appendChild(node);&#10;        slides[counter] = new Object();&#10;        slides[counter][&quot;original_element&quot;] = originalNode;&#10;        slides[counter][&quot;element&quot;] = node;&#10;&#10;        // Set build in transition.&#10;        slides[counter][&quot;transitionIn&quot;] = new Object();&#10;&#10;        var dict;&#10;&#10;        if (node.hasAttributeNS(NSS[&quot;jessyink&quot;], &quot;transitionIn&quot;))&#10;            dict = propStrToDict(node.getAttributeNS(NSS[&quot;jessyink&quot;], &quot;transitionIn&quot;));&#10;        else&#10;            dict = defaultTransitionInDict;&#10;&#10;        slides[counter][&quot;transitionIn&quot;][&quot;name&quot;] = dict[&quot;name&quot;];&#10;        slides[counter][&quot;transitionIn&quot;][&quot;options&quot;] = new Object();&#10;&#10;        for (key in dict)&#10;            if (key != &quot;name&quot;)&#10;                slides[counter][&quot;transitionIn&quot;][&quot;options&quot;][key] = dict[key];&#10;&#10;        // Set build out transition.&#10;        slides[counter][&quot;transitionOut&quot;] = new Object();&#10;&#10;        if (node.hasAttributeNS(NSS[&quot;jessyink&quot;], &quot;transitionOut&quot;))&#10;            dict = propStrToDict(node.getAttributeNS(NSS[&quot;jessyink&quot;], &quot;transitionOut&quot;));&#10;        else&#10;            dict = defaultTransitionOutDict;&#10;&#10;        slides[counter][&quot;transitionOut&quot;][&quot;name&quot;] = dict[&quot;name&quot;];&#10;        slides[counter][&quot;transitionOut&quot;][&quot;options&quot;] = new Object();&#10;&#10;        for (key in dict)&#10;            if (key != &quot;name&quot;)&#10;                slides[counter][&quot;transitionOut&quot;][&quot;options&quot;][key] = dict[key];&#10;&#10;        // Copy master slide content.&#10;        if (masterSlide)&#10;        {&#10;            var clonedNode = suffixNodeIds(masterSlide.cloneNode(true), &quot;_&quot; + counter);&#10;            clonedNode.removeAttributeNS(NSS[&quot;inkscape&quot;], &quot;groupmode&quot;);&#10;            clonedNode.removeAttributeNS(NSS[&quot;inkscape&quot;], &quot;label&quot;);&#10;            clonedNode.style.display = &quot;inherit&quot;;&#10;&#10;            node.insertBefore(clonedNode, node.firstChild);&#10;        }&#10;&#10;        // Setting clip path.&#10;        node.setAttribute(&quot;clip-path&quot;, &quot;url(#jessyInkSlideClipPath)&quot;);&#10;&#10;        // Substitute auto texts.&#10;        substituteAutoTexts(node, node.getAttributeNS(NSS[&quot;inkscape&quot;], &quot;label&quot;), counter + 1, tempSlides.length);&#10;&#10;        node.removeAttributeNS(NSS[&quot;inkscape&quot;], &quot;groupmode&quot;);&#10;        node.removeAttributeNS(NSS[&quot;inkscape&quot;], &quot;label&quot;);&#10;&#10;        // Set effects.&#10;        var tempEffects = new Array();&#10;        var groups = new Object();&#10;&#10;        for (var IOCounter = 0; IOCounter &lt;= 1; IOCounter++)&#10;        {&#10;            var propName = &quot;&quot;;&#10;            var dir = 0;&#10;&#10;            if (IOCounter == 0)&#10;            {&#10;                propName = &quot;effectIn&quot;;&#10;                dir = 1;&#10;            }&#10;            else if (IOCounter == 1)&#10;            {&#10;                propName = &quot;effectOut&quot;;&#10;                dir = -1;&#10;            }&#10;&#10;            var effects = getElementsByPropertyNS(node, NSS[&quot;jessyink&quot;], propName);&#10;&#10;            for (var effectCounter = 0; effectCounter &lt; effects.length; effectCounter++)&#10;            {&#10;                var element = document.getElementById(effects[effectCounter]);&#10;                var dict = propStrToDict(element.getAttributeNS(NSS[&quot;jessyink&quot;], propName));&#10;&#10;                // Put every element that has an effect associated with it, into its own group.&#10;                // Unless of course, we already put it into its own group.&#10;                if (!(groups[element.id]))&#10;                {&#10;                    var newGroup = document.createElementNS(NSS[&quot;svg&quot;], &quot;g&quot;);&#10;&#10;                    element.parentNode.insertBefore(newGroup, element);&#10;                    newGroup.appendChild(element.parentNode.removeChild(element));&#10;                    groups[element.id] = newGroup;&#10;                }&#10;&#10;                var effectDict = new Object();&#10;&#10;                effectDict[&quot;effect&quot;] = dict[&quot;name&quot;];&#10;                effectDict[&quot;dir&quot;] = dir;&#10;                effectDict[&quot;element&quot;] = groups[element.id];&#10;&#10;                for (var option in dict)&#10;                {&#10;                    if ((option != &quot;name&quot;) &amp;&amp; (option != &quot;order&quot;))&#10;                    {&#10;                        if (!effectDict[&quot;options&quot;])&#10;                            effectDict[&quot;options&quot;] = new Object();&#10;&#10;                        effectDict[&quot;options&quot;][option] = dict[option];&#10;                    }&#10;                }&#10;&#10;                if (!tempEffects[dict[&quot;order&quot;]])&#10;                    tempEffects[dict[&quot;order&quot;]] = new Array();&#10;&#10;                tempEffects[dict[&quot;order&quot;]][tempEffects[dict[&quot;order&quot;]].length] = effectDict;&#10;            }&#10;        }&#10;&#10;        // Make invisible, but keep in rendering tree to ensure that bounding box can be calculated.&#10;        node.setAttribute(&quot;opacity&quot;,0);&#10;        node.style.display = &quot;inherit&quot;;&#10;&#10;        // Create a transform group.&#10;        var transformGroup = document.createElementNS(NSS[&quot;svg&quot;], &quot;g&quot;);&#10;&#10;        // Add content to transform group.&#10;        while (node.firstChild)&#10;            transformGroup.appendChild(node.firstChild);&#10;&#10;        // Transfer the transform attribute from the node to the transform group.&#10;        if (node.getAttribute(&quot;transform&quot;))&#10;        {&#10;            transformGroup.setAttribute(&quot;transform&quot;, node.getAttribute(&quot;transform&quot;));&#10;            node.removeAttribute(&quot;transform&quot;);&#10;        }&#10;&#10;        // Create a view group.&#10;        var viewGroup = document.createElementNS(NSS[&quot;svg&quot;], &quot;g&quot;);&#10;&#10;        viewGroup.appendChild(transformGroup);&#10;        slides[counter][&quot;viewGroup&quot;] = node.appendChild(viewGroup);&#10;&#10;        // Insert background.&#10;        if (BACKGROUND_COLOR != null)&#10;        {&#10;            var rectNode = document.createElementNS(NSS[&quot;svg&quot;], &quot;rect&quot;);&#10;&#10;            rectNode.setAttribute(&quot;x&quot;, 0);&#10;            rectNode.setAttribute(&quot;y&quot;, 0);&#10;            rectNode.setAttribute(&quot;width&quot;, WIDTH);&#10;            rectNode.setAttribute(&quot;height&quot;, HEIGHT);&#10;            rectNode.setAttribute(&quot;id&quot;, &quot;jessyInkBackground&quot; + counter);&#10;            rectNode.setAttribute(&quot;fill&quot;, BACKGROUND_COLOR);&#10;&#10;            slides[counter][&quot;viewGroup&quot;].insertBefore(rectNode, slides[counter][&quot;viewGroup&quot;].firstChild);&#10;        }&#10;&#10;        // Set views.&#10;        var tempViews = new Array();&#10;        var views = getElementsByPropertyNS(node, NSS[&quot;jessyink&quot;], &quot;view&quot;);&#10;        var matrixOld = (new matrixSVG()).fromElements(1, 0, 0, 0, 1, 0, 0, 0, 1);&#10;&#10;        // Set initial view even if there are no other views.&#10;        slides[counter][&quot;viewGroup&quot;].setAttribute(&quot;transform&quot;, matrixOld.toAttribute());&#10;        slides[counter].initialView = matrixOld.toAttribute();&#10;&#10;        for (var viewCounter = 0; viewCounter &lt; views.length; viewCounter++)&#10;        {&#10;            var element = document.getElementById(views[viewCounter]);&#10;            var dict = propStrToDict(element.getAttributeNS(NSS[&quot;jessyink&quot;], &quot;view&quot;));&#10;&#10;            if (dict[&quot;order&quot;] == 0)&#10;            {&#10;                matrixOld = pointMatrixToTransformation(rectToMatrix(element)).mult((new matrixSVG()).fromSVGMatrix(slides[counter].viewGroup.getScreenCTM()).inv().mult((new matrixSVG()).fromSVGMatrix(element.parentNode.getScreenCTM())).inv());&#10;                slides[counter].initialView = matrixOld.toAttribute();&#10;            }&#10;            else&#10;            {&#10;                var effectDict = new Object();&#10;&#10;                effectDict[&quot;effect&quot;] = dict[&quot;name&quot;];&#10;                effectDict[&quot;dir&quot;] = 1;&#10;                effectDict[&quot;element&quot;] = slides[counter][&quot;viewGroup&quot;];&#10;                effectDict[&quot;order&quot;] = dict[&quot;order&quot;];&#10;&#10;                for (var option in dict)&#10;                {&#10;                    if ((option != &quot;name&quot;) &amp;&amp; (option != &quot;order&quot;))&#10;                    {&#10;                        if (!effectDict[&quot;options&quot;])&#10;                            effectDict[&quot;options&quot;] = new Object();&#10;&#10;                        effectDict[&quot;options&quot;][option] = dict[option];&#10;                    }&#10;                }&#10;&#10;                effectDict[&quot;options&quot;][&quot;matrixNew&quot;] = pointMatrixToTransformation(rectToMatrix(element)).mult((new matrixSVG()).fromSVGMatrix(slides[counter].viewGroup.getScreenCTM()).inv().mult((new matrixSVG()).fromSVGMatrix(element.parentNode.getScreenCTM())).inv());&#10;&#10;                tempViews[dict[&quot;order&quot;]] = effectDict;&#10;            }&#10;&#10;            // Remove element.&#10;            element.parentNode.removeChild(element);&#10;        }&#10;&#10;        // Consolidate view array and append it to the effect array.&#10;        if (tempViews.length &gt; 0)&#10;        {&#10;            for (var viewCounter = 0; viewCounter &lt; tempViews.length; viewCounter++)&#10;            {&#10;                if (tempViews[viewCounter])&#10;                {&#10;                    tempViews[viewCounter][&quot;options&quot;][&quot;matrixOld&quot;] = matrixOld;&#10;                    matrixOld = tempViews[viewCounter][&quot;options&quot;][&quot;matrixNew&quot;];&#10;&#10;                    if (!tempEffects[tempViews[viewCounter][&quot;order&quot;]])&#10;                        tempEffects[tempViews[viewCounter][&quot;order&quot;]] = new Array();&#10;&#10;                    tempEffects[tempViews[viewCounter][&quot;order&quot;]][tempEffects[tempViews[viewCounter][&quot;order&quot;]].length] = tempViews[viewCounter];&#10;                }&#10;            }&#10;        }&#10;&#10;        // Set consolidated effect array.&#10;        if (tempEffects.length &gt; 0)&#10;        {&#10;            slides[counter][&quot;effects&quot;] = new Array();&#10;&#10;            for (var effectCounter = 0; effectCounter &lt; tempEffects.length; effectCounter++)&#10;            {&#10;                if (tempEffects[effectCounter])&#10;                    slides[counter][&quot;effects&quot;][slides[counter][&quot;effects&quot;].length] = tempEffects[effectCounter];&#10;            }&#10;        }&#10;&#10;        node.setAttribute(&quot;onmouseover&quot;, &quot;if ((currentMode == INDEX_MODE) &amp;&amp; ( activeSlide != &quot; + counter + &quot;)) { indexSetActiveSlide(&quot; + counter + &quot;); };&quot;);&#10;&#10;        // Set visibility for initial state.&#10;        if (counter == activeSlide)&#10;        {&#10;            node.style.display = &quot;inherit&quot;;&#10;            node.setAttribute(&quot;opacity&quot;,1);&#10;        }&#10;        else&#10;        {&#10;            node.style.display = &quot;none&quot;;&#10;            node.setAttribute(&quot;opacity&quot;,0);&#10;        }&#10;    }&#10;&#10;    // Set key handler.&#10;    var jessyInkObjects = document.getElementsByTagNameNS(NSS[&quot;svg&quot;], &quot;g&quot;);&#10;&#10;    for (var counter = 0; counter &lt; jessyInkObjects.length; counter++)&#10;    {&#10;        var elem = jessyInkObjects[counter];&#10;&#10;        if (elem.getAttributeNS(NSS[&quot;jessyink&quot;], &quot;customKeyBindings&quot;))&#10;        {&#10;            if (elem.getCustomKeyBindings != undefined)&#10;                keyCodeDictionary = elem.getCustomKeyBindings();&#10;&#10;            if (elem.getCustomCharBindings != undefined)&#10;                charCodeDictionary = elem.getCustomCharBindings();&#10;        }&#10;    }&#10;&#10;    // Set mouse handler.&#10;    var jessyInkMouseHandler = document.getElementsByTagNameNS(NSS[&quot;jessyink&quot;], &quot;mousehandler&quot;);&#10;&#10;    for (var counter = 0; counter &lt; jessyInkMouseHandler.length; counter++)&#10;    {&#10;        var elem = jessyInkMouseHandler[counter];&#10;&#10;        if (elem.getMouseHandler != undefined)&#10;        {&#10;            var tempDict = elem.getMouseHandler();&#10;&#10;            for (mode in tempDict)&#10;            {&#10;                if (!mouseHandlerDictionary[mode])&#10;                    mouseHandlerDictionary[mode] = new Object();&#10;&#10;                for (handler in tempDict[mode])&#10;                    mouseHandlerDictionary[mode][handler] = tempDict[mode][handler];&#10;            }&#10;        }&#10;    }&#10;&#10;    // Check effect number.&#10;    if ((activeEffect &lt; 0) || (!slides[activeSlide].effects))&#10;    {&#10;        activeEffect = 0;&#10;    }&#10;    else if (activeEffect &gt; slides[activeSlide].effects.length)&#10;    {&#10;        activeEffect = slides[activeSlide].effects.length;&#10;    }&#10;&#10;    createProgressBar(JessyInkPresentationLayer);&#10;    hideProgressBar();&#10;    setProgressBarValue(activeSlide);&#10;    setTimeIndicatorValue(0);&#10;    setInterval(&quot;updateTimer()&quot;, 1000);&#10;    setSlideToState(activeSlide, activeEffect);&#10;    jessyInkInitialised = true;&#10;}&#10;&#10;/** Function to substitute the auto-texts.&#10; *&#10; *  @param node the node&#10; *  @param slideName name of the slide the node is on&#10; *  @param slideNumber number of the slide the node is on&#10; *  @param numberOfSlides number of slides in the presentation&#10; */&#10;function substituteAutoTexts(node, slideName, slideNumber, numberOfSlides)&#10;{&#10;    var texts = node.getElementsByTagNameNS(NSS[&quot;svg&quot;], &quot;tspan&quot;);&#10;&#10;    for (var textCounter = 0; textCounter &lt; texts.length; textCounter++)&#10;    {&#10;        if (texts[textCounter].getAttributeNS(NSS[&quot;jessyink&quot;], &quot;autoText&quot;) == &quot;slideNumber&quot;)&#10;            texts[textCounter].firstChild.nodeValue = slideNumber;&#10;        else if (texts[textCounter].getAttributeNS(NSS[&quot;jessyink&quot;], &quot;autoText&quot;) == &quot;numberOfSlides&quot;)&#10;            texts[textCounter].firstChild.nodeValue = numberOfSlides;&#10;        else if (texts[textCounter].getAttributeNS(NSS[&quot;jessyink&quot;], &quot;autoText&quot;) == &quot;slideTitle&quot;)&#10;            texts[textCounter].firstChild.nodeValue = slideName;&#10;    }&#10;}&#10;&#10;/** Convenience function to get an element depending on whether it has a property with a particular name.&#10; *    This function emulates some dearly missed XPath functionality.&#10; *&#10; *  @param node the node&#10; *  @param namespace namespace of the attribute&#10; *  @param name attribute name&#10; */&#10;function getElementsByPropertyNS(node, namespace, name)&#10;{&#10;    var elems = new Array();&#10;&#10;    if (node.getAttributeNS(namespace, name))&#10;        elems.push(node.getAttribute(&quot;id&quot;));&#10;&#10;    for (var counter = 0; counter &lt; node.childNodes.length; counter++)&#10;    {&#10;        if (node.childNodes[counter].nodeType == 1)&#10;            elems = elems.concat(getElementsByPropertyNS(node.childNodes[counter], namespace, name));&#10;    }&#10;&#10;    return elems;&#10;}&#10;&#10;/** Function to dispatch the next effect, if there is none left, change the slide.&#10; *&#10; *  @param dir direction of the change (1 = forwards, -1 = backwards)&#10; */&#10;function dispatchEffects(dir)&#10;{&#10;    if (slides[activeSlide][&quot;effects&quot;] &amp;&amp; (((dir == 1) &amp;&amp; (activeEffect &lt; slides[activeSlide][&quot;effects&quot;].length)) || ((dir == -1) &amp;&amp; (activeEffect &gt; 0))))&#10;    {&#10;        processingEffect = true;&#10;&#10;        if (dir == 1)&#10;        {&#10;            effectArray = slides[activeSlide][&quot;effects&quot;][activeEffect];&#10;            activeEffect += dir;&#10;        }&#10;        else if (dir == -1)&#10;        {&#10;            activeEffect += dir;&#10;            effectArray = slides[activeSlide][&quot;effects&quot;][activeEffect];&#10;        }&#10;&#10;        transCounter = 0;&#10;        startTime = (new Date()).getTime();&#10;        lastFrameTime = null;&#10;        effect(dir);&#10;    }&#10;    else if (((dir == 1) &amp;&amp; (activeSlide &lt; (slides.length - 1))) || (((dir == -1) &amp;&amp; (activeSlide &gt; 0))))&#10;    {&#10;        changeSlide(dir);&#10;    }&#10;}&#10;&#10;/** Function to skip effects and directly either put the slide into start or end state or change slides.&#10; *&#10; *  @param dir direction of the change (1 = forwards, -1 = backwards)&#10; */&#10;function skipEffects(dir)&#10;{&#10;    if (slides[activeSlide][&quot;effects&quot;] &amp;&amp; (((dir == 1) &amp;&amp; (activeEffect &lt; slides[activeSlide][&quot;effects&quot;].length)) || ((dir == -1) &amp;&amp; (activeEffect &gt; 0))))&#10;    {&#10;        processingEffect = true;&#10;&#10;        if (slides[activeSlide][&quot;effects&quot;] &amp;&amp; (dir == 1))&#10;            activeEffect = slides[activeSlide][&quot;effects&quot;].length;&#10;        else&#10;            activeEffect = 0;&#10;&#10;        if (dir == 1)&#10;            setSlideToState(activeSlide, STATE_END);&#10;        else&#10;            setSlideToState(activeSlide, STATE_START);&#10;&#10;        processingEffect = false;&#10;    }&#10;    else if (((dir == 1) &amp;&amp; (activeSlide &lt; (slides.length - 1))) || (((dir == -1) &amp;&amp; (activeSlide &gt; 0))))&#10;    {&#10;        changeSlide(dir);&#10;    }&#10;}&#10;&#10;/** Function to change between slides.&#10; *&#10; *  @param dir direction (1 = forwards, -1 = backwards)&#10; */&#10;function changeSlide(dir)&#10;{&#10;    processingEffect = true;&#10;    effectArray = new Array();&#10;&#10;    effectArray[0] = new Object();&#10;    if (dir == 1)&#10;    {&#10;        effectArray[0][&quot;effect&quot;] = slides[activeSlide][&quot;transitionOut&quot;][&quot;name&quot;];&#10;        effectArray[0][&quot;options&quot;] = slides[activeSlide][&quot;transitionOut&quot;][&quot;options&quot;];&#10;        effectArray[0][&quot;dir&quot;] = -1;&#10;    }&#10;    else if (dir == -1)&#10;    {&#10;        effectArray[0][&quot;effect&quot;] = slides[activeSlide][&quot;transitionIn&quot;][&quot;name&quot;];&#10;        effectArray[0][&quot;options&quot;] = slides[activeSlide][&quot;transitionIn&quot;][&quot;options&quot;];&#10;        effectArray[0][&quot;dir&quot;] = 1;&#10;    }&#10;    effectArray[0][&quot;element&quot;] = slides[activeSlide][&quot;element&quot;];&#10;&#10;    activeSlide += dir;&#10;    setProgressBarValue(activeSlide);&#10;&#10;    effectArray[1] = new Object();&#10;&#10;    if (dir == 1)&#10;    {&#10;        effectArray[1][&quot;effect&quot;] = slides[activeSlide][&quot;transitionIn&quot;][&quot;name&quot;];&#10;        effectArray[1][&quot;options&quot;] = slides[activeSlide][&quot;transitionIn&quot;][&quot;options&quot;];&#10;        effectArray[1][&quot;dir&quot;] = 1;&#10;    }&#10;    else if (dir == -1)&#10;    {&#10;        effectArray[1][&quot;effect&quot;] = slides[activeSlide][&quot;transitionOut&quot;][&quot;name&quot;];&#10;        effectArray[1][&quot;options&quot;] = slides[activeSlide][&quot;transitionOut&quot;][&quot;options&quot;];&#10;        effectArray[1][&quot;dir&quot;] = -1;&#10;    }&#10;&#10;    effectArray[1][&quot;element&quot;] = slides[activeSlide][&quot;element&quot;];&#10;&#10;    if (slides[activeSlide][&quot;effects&quot;] &amp;&amp; (dir == -1))&#10;        activeEffect = slides[activeSlide][&quot;effects&quot;].length;&#10;    else&#10;        activeEffect = 0;&#10;&#10;    if (dir == -1)&#10;        setSlideToState(activeSlide, STATE_END);&#10;    else&#10;        setSlideToState(activeSlide, STATE_START);&#10;&#10;    transCounter = 0;&#10;    startTime = (new Date()).getTime();&#10;    lastFrameTime = null;&#10;    effect(dir);&#10;}&#10;&#10;/** Function to toggle between index and slide mode.&#10;*/&#10;function toggleSlideIndex()&#10;{&#10;    var suspendHandle = ROOT_NODE.suspendRedraw(500);&#10;&#10;    if (currentMode == SLIDE_MODE)&#10;    {&#10;        hideProgressBar();&#10;        INDEX_OFFSET = -1;&#10;        indexSetPageSlide(activeSlide);&#10;        currentMode = INDEX_MODE;&#10;    }&#10;    else if (currentMode == INDEX_MODE)&#10;    {&#10;        for (var counter = 0; counter &lt; slides.length; counter++)&#10;        {&#10;            slides[counter][&quot;element&quot;].setAttribute(&quot;transform&quot;,&quot;scale(1)&quot;);&#10;&#10;            if (counter == activeSlide)&#10;            {&#10;                slides[counter][&quot;element&quot;].style.display = &quot;inherit&quot;;&#10;                slides[counter][&quot;element&quot;].setAttribute(&quot;opacity&quot;,1);&#10;                activeEffect = 0;&#10;            }&#10;            else&#10;            {&#10;                slides[counter][&quot;element&quot;].setAttribute(&quot;opacity&quot;,0);&#10;                slides[counter][&quot;element&quot;].style.display = &quot;none&quot;;&#10;            }&#10;        }&#10;        currentMode = SLIDE_MODE;&#10;        setSlideToState(activeSlide, STATE_START);&#10;        setProgressBarValue(activeSlide);&#10;&#10;        if (progress_bar_visible)&#10;        {&#10;            showProgressBar();&#10;        }&#10;    }&#10;&#10;    ROOT_NODE.unsuspendRedraw(suspendHandle);&#10;    ROOT_NODE.forceRedraw();&#10;}&#10;&#10;/** Function to run an effect.&#10; *&#10; *  @param dir direction in which to play the effect (1 = forwards, -1 = backwards)&#10; */&#10;function effect(dir)&#10;{&#10;    var done = true;&#10;&#10;    var suspendHandle = ROOT_NODE.suspendRedraw(200);&#10;&#10;    for (var counter = 0; counter &lt; effectArray.length; counter++)&#10;    {&#10;        if (effectArray[counter][&quot;effect&quot;] == &quot;fade&quot;)&#10;            done &amp;= fade(parseInt(effectArray[counter][&quot;dir&quot;]) * dir, effectArray[counter][&quot;element&quot;], transCounter, effectArray[counter][&quot;options&quot;]);&#10;        else if (effectArray[counter][&quot;effect&quot;] == &quot;appear&quot;)&#10;            done &amp;= appear(parseInt(effectArray[counter][&quot;dir&quot;]) * dir, effectArray[counter][&quot;element&quot;], transCounter, effectArray[counter][&quot;options&quot;]);&#10;        else if (effectArray[counter][&quot;effect&quot;] == &quot;pop&quot;)&#10;            done &amp;= pop(parseInt(effectArray[counter][&quot;dir&quot;]) * dir, effectArray[counter][&quot;element&quot;], transCounter, effectArray[counter][&quot;options&quot;]);&#10;        else if (effectArray[counter][&quot;effect&quot;] == &quot;view&quot;)&#10;            done &amp;= view(parseInt(effectArray[counter][&quot;dir&quot;]) * dir, effectArray[counter][&quot;element&quot;], transCounter, effectArray[counter][&quot;options&quot;]);&#10;    }&#10;&#10;    ROOT_NODE.unsuspendRedraw(suspendHandle);&#10;    ROOT_NODE.forceRedraw();&#10;&#10;    if (!done)&#10;    {&#10;        var currentTime = (new Date()).getTime();&#10;        var timeDiff = 1;&#10;&#10;        transCounter = currentTime - startTime;&#10;&#10;        if (lastFrameTime != null)&#10;        {&#10;            timeDiff = timeStep - (currentTime - lastFrameTime);&#10;&#10;            if (timeDiff &lt;= 0)&#10;                timeDiff = 1;&#10;        }&#10;&#10;        lastFrameTime = currentTime;&#10;&#10;        window.setTimeout(&quot;effect(&quot; + dir + &quot;)&quot;, timeDiff);&#10;    }&#10;    else&#10;    {&#10;        window.location.hash = (activeSlide + 1) + '_' + activeEffect;&#10;        processingEffect = false;&#10;    }&#10;}&#10;&#10;/** Function to display the index sheet.&#10; *&#10; *  @param offsetNumber offset number&#10; */&#10;function displayIndex(offsetNumber)&#10;{&#10;    var offsetX = 0;&#10;    var offsetY = 0;&#10;&#10;    if (offsetNumber &lt; 0)&#10;        offsetNumber = 0;&#10;    else if (offsetNumber &gt;= slides.length)&#10;        offsetNumber = slides.length - 1;&#10;&#10;    for (var counter = 0; counter &lt; slides.length; counter++)&#10;    {&#10;        if ((counter &lt; offsetNumber) || (counter &gt; offsetNumber + INDEX_COLUMNS * INDEX_COLUMNS - 1))&#10;        {&#10;            slides[counter][&quot;element&quot;].setAttribute(&quot;opacity&quot;,0);&#10;            slides[counter][&quot;element&quot;].style.display = &quot;none&quot;;&#10;        }&#10;        else&#10;        {&#10;            offsetX = ((counter - offsetNumber) % INDEX_COLUMNS) * WIDTH;&#10;            offsetY = Math.floor((counter - offsetNumber) / INDEX_COLUMNS) * HEIGHT;&#10;&#10;            slides[counter][&quot;element&quot;].setAttribute(&quot;transform&quot;,&quot;scale(&quot;+1/INDEX_COLUMNS+&quot;) translate(&quot;+offsetX+&quot;,&quot;+offsetY+&quot;)&quot;);&#10;            slides[counter][&quot;element&quot;].style.display = &quot;inherit&quot;;&#10;            slides[counter][&quot;element&quot;].setAttribute(&quot;opacity&quot;,0.5);&#10;        }&#10;&#10;        setSlideToState(counter, STATE_END);&#10;    }&#10;&#10;    //do we need to save the current offset?&#10;    if (INDEX_OFFSET != offsetNumber)&#10;        INDEX_OFFSET = offsetNumber;&#10;}&#10;&#10;/** Function to set the active slide in the slide view.&#10; *&#10; *  @param nbr index of the active slide&#10; */&#10;function slideSetActiveSlide(nbr)&#10;{&#10;    if (nbr &gt;= slides.length)&#10;        nbr = slides.length - 1;&#10;    else if (nbr &lt; 0)&#10;        nbr = 0;&#10;&#10;    slides[activeSlide][&quot;element&quot;].setAttribute(&quot;opacity&quot;,0);&#10;    slides[activeSlide][&quot;element&quot;].style.display = &quot;none&quot;;&#10;&#10;    activeSlide = parseInt(nbr);&#10;&#10;    setSlideToState(activeSlide, STATE_START);&#10;    slides[activeSlide][&quot;element&quot;].style.display = &quot;inherit&quot;;&#10;    slides[activeSlide][&quot;element&quot;].setAttribute(&quot;opacity&quot;,1);&#10;&#10;    activeEffect = 0;&#10;    setProgressBarValue(nbr);&#10;}&#10;&#10;/** Function to set the active slide in the index view.&#10; *&#10; *  @param nbr index of the active slide&#10; */&#10;function indexSetActiveSlide(nbr)&#10;{&#10;    if (nbr &gt;= slides.length)&#10;        nbr = slides.length - 1;&#10;    else if (nbr &lt; 0)&#10;        nbr = 0;&#10;&#10;    slides[activeSlide][&quot;element&quot;].setAttribute(&quot;opacity&quot;,0.5);&#10;&#10;    activeSlide = parseInt(nbr);&#10;    window.location.hash = (activeSlide + 1) + '_0';&#10;&#10;    slides[activeSlide][&quot;element&quot;].setAttribute(&quot;opacity&quot;,1);&#10;}&#10;&#10;/** Function to set the page and active slide in index view.&#10; *&#10; *  @param nbr index of the active slide&#10; *&#10; *  NOTE: To force a redraw,&#10; *  set INDEX_OFFSET to -1 before calling indexSetPageSlide().&#10; *&#10; *  This is necessary for zooming (otherwise the index might not&#10; *  get redrawn) and when switching to index mode.&#10; *&#10; *  INDEX_OFFSET = -1&#10; *  indexSetPageSlide(activeSlide);&#10; */&#10;function indexSetPageSlide(nbr)&#10;{&#10;    if (nbr &gt;= slides.length)&#10;        nbr = slides.length - 1;&#10;    else if (nbr &lt; 0)&#10;        nbr = 0;&#10;&#10;    //calculate the offset&#10;    var offset = nbr - nbr % (INDEX_COLUMNS * INDEX_COLUMNS);&#10;&#10;    if (offset &lt; 0)&#10;        offset = 0;&#10;&#10;    //if different from kept offset, then record and change the page&#10;    if (offset != INDEX_OFFSET)&#10;    {&#10;        INDEX_OFFSET = offset;&#10;        displayIndex(INDEX_OFFSET);&#10;    }&#10;&#10;    //set the active slide&#10;    indexSetActiveSlide(nbr);&#10;}&#10;&#10;/** Event handler for key press.&#10; *&#10; *  @param e the event&#10; */&#10;function keydown(e)&#10;{&#10;    if (!e)&#10;        e = window.event;&#10;&#10;    code = e.keyCode || e.charCode;&#10;&#10;    if (!processingEffect &amp;&amp; keyCodeDictionary[currentMode] &amp;&amp; keyCodeDictionary[currentMode][code])&#10;        return keyCodeDictionary[currentMode][code]();&#10;    else&#10;        document.onkeypress = keypress;&#10;}&#10;// Set event handler for key down.&#10;document.onkeydown = keydown;&#10;&#10;/** Event handler for key press.&#10; *&#10; *  @param e the event&#10; */&#10;function keypress(e)&#10;{&#10;    document.onkeypress = null;&#10;&#10;    if (!e)&#10;        e = window.event;&#10;&#10;    str = String.fromCharCode(e.keyCode || e.charCode);&#10;&#10;    if (!processingEffect &amp;&amp; charCodeDictionary[currentMode] &amp;&amp; charCodeDictionary[currentMode][str])&#10;        return charCodeDictionary[currentMode][str]();&#10;}&#10;&#10;/** Function to supply the default char code dictionary.&#10; *&#10; * @returns default char code dictionary&#10; */&#10;function getDefaultCharCodeDictionary()&#10;{&#10;    var charCodeDict = new Object();&#10;&#10;    charCodeDict[SLIDE_MODE] = new Object();&#10;    charCodeDict[INDEX_MODE] = new Object();&#10;    charCodeDict[DRAWING_MODE] = new Object();&#10;&#10;    charCodeDict[SLIDE_MODE][&quot;i&quot;] = function () { return toggleSlideIndex(); };&#10;    charCodeDict[SLIDE_MODE][&quot;d&quot;] = function () { return slideSwitchToDrawingMode(); };&#10;    charCodeDict[SLIDE_MODE][&quot;D&quot;] = function () { return slideQueryDuration(); };&#10;    charCodeDict[SLIDE_MODE][&quot;n&quot;] = function () { return slideAddSlide(activeSlide); };&#10;    charCodeDict[SLIDE_MODE][&quot;p&quot;] = function () { return slideToggleProgressBarVisibility(); };&#10;    charCodeDict[SLIDE_MODE][&quot;t&quot;] = function () { return slideResetTimer(); };&#10;    charCodeDict[SLIDE_MODE][&quot;e&quot;] = function () { return slideUpdateExportLayer(); };&#10;&#10;    charCodeDict[DRAWING_MODE][&quot;d&quot;] = function () { return drawingSwitchToSlideMode(); };&#10;    charCodeDict[DRAWING_MODE][&quot;0&quot;] = function () { return drawingResetPathWidth(); };&#10;    charCodeDict[DRAWING_MODE][&quot;1&quot;] = function () { return drawingSetPathWidth(1.0); };&#10;    charCodeDict[DRAWING_MODE][&quot;3&quot;] = function () { return drawingSetPathWidth(3.0); };&#10;    charCodeDict[DRAWING_MODE][&quot;5&quot;] = function () { return drawingSetPathWidth(5.0); };&#10;    charCodeDict[DRAWING_MODE][&quot;7&quot;] = function () { return drawingSetPathWidth(7.0); };&#10;    charCodeDict[DRAWING_MODE][&quot;9&quot;] = function () { return drawingSetPathWidth(9.0); };&#10;    charCodeDict[DRAWING_MODE][&quot;b&quot;] = function () { return drawingSetPathColour(&quot;blue&quot;); };&#10;    charCodeDict[DRAWING_MODE][&quot;c&quot;] = function () { return drawingSetPathColour(&quot;cyan&quot;); };&#10;    charCodeDict[DRAWING_MODE][&quot;g&quot;] = function () { return drawingSetPathColour(&quot;green&quot;); };&#10;    charCodeDict[DRAWING_MODE][&quot;k&quot;] = function () { return drawingSetPathColour(&quot;black&quot;); };&#10;    charCodeDict[DRAWING_MODE][&quot;m&quot;] = function () { return drawingSetPathColour(&quot;magenta&quot;); };&#10;    charCodeDict[DRAWING_MODE][&quot;o&quot;] = function () { return drawingSetPathColour(&quot;orange&quot;); };&#10;    charCodeDict[DRAWING_MODE][&quot;r&quot;] = function () { return drawingSetPathColour(&quot;red&quot;); };&#10;    charCodeDict[DRAWING_MODE][&quot;w&quot;] = function () { return drawingSetPathColour(&quot;white&quot;); };&#10;    charCodeDict[DRAWING_MODE][&quot;y&quot;] = function () { return drawingSetPathColour(&quot;yellow&quot;); };&#10;    charCodeDict[DRAWING_MODE][&quot;z&quot;] = function () { return drawingUndo(); };&#10;&#10;    charCodeDict[INDEX_MODE][&quot;i&quot;] = function () { return toggleSlideIndex(); };&#10;    charCodeDict[INDEX_MODE][&quot;-&quot;] = function () { return indexDecreaseNumberOfColumns(); };&#10;    charCodeDict[INDEX_MODE][&quot;=&quot;] = function () { return indexIncreaseNumberOfColumns(); };&#10;    charCodeDict[INDEX_MODE][&quot;+&quot;] = function () { return indexIncreaseNumberOfColumns(); };&#10;    charCodeDict[INDEX_MODE][&quot;0&quot;] = function () { return indexResetNumberOfColumns(); };&#10;&#10;    return charCodeDict;&#10;}&#10;&#10;/** Function to supply the default key code dictionary.&#10; *&#10; * @returns default key code dictionary&#10; */&#10;function getDefaultKeyCodeDictionary()&#10;{&#10;    var keyCodeDict = new Object();&#10;&#10;    keyCodeDict[SLIDE_MODE] = new Object();&#10;    keyCodeDict[INDEX_MODE] = new Object();&#10;    keyCodeDict[DRAWING_MODE] = new Object();&#10;&#10;    keyCodeDict[SLIDE_MODE][LEFT_KEY] = function() { return dispatchEffects(-1); };&#10;    keyCodeDict[SLIDE_MODE][RIGHT_KEY] = function() { return dispatchEffects(1); };&#10;    keyCodeDict[SLIDE_MODE][UP_KEY] = function() { return skipEffects(-1); };&#10;    keyCodeDict[SLIDE_MODE][DOWN_KEY] = function() { return skipEffects(1); };&#10;    keyCodeDict[SLIDE_MODE][PAGE_UP_KEY] = function() { return dispatchEffects(-1); };&#10;    keyCodeDict[SLIDE_MODE][PAGE_DOWN_KEY] = function() { return dispatchEffects(1); };&#10;    keyCodeDict[SLIDE_MODE][HOME_KEY] = function() { return slideSetActiveSlide(0); };&#10;    keyCodeDict[SLIDE_MODE][END_KEY] = function() { return slideSetActiveSlide(slides.length - 1); };&#10;    keyCodeDict[SLIDE_MODE][SPACE_KEY] = function() { return dispatchEffects(1); };&#10;&#10;    keyCodeDict[INDEX_MODE][LEFT_KEY] = function() { return indexSetPageSlide(activeSlide - 1); };&#10;    keyCodeDict[INDEX_MODE][RIGHT_KEY] = function() { return indexSetPageSlide(activeSlide + 1); };&#10;    keyCodeDict[INDEX_MODE][UP_KEY] = function() { return indexSetPageSlide(activeSlide - INDEX_COLUMNS); };&#10;    keyCodeDict[INDEX_MODE][DOWN_KEY] = function() { return indexSetPageSlide(activeSlide + INDEX_COLUMNS); };&#10;    keyCodeDict[INDEX_MODE][PAGE_UP_KEY] = function() { return indexSetPageSlide(activeSlide - INDEX_COLUMNS * INDEX_COLUMNS); };&#10;    keyCodeDict[INDEX_MODE][PAGE_DOWN_KEY] = function() { return indexSetPageSlide(activeSlide + INDEX_COLUMNS * INDEX_COLUMNS); };&#10;    keyCodeDict[INDEX_MODE][HOME_KEY] = function() { return indexSetPageSlide(0); };&#10;    keyCodeDict[INDEX_MODE][END_KEY] = function() { return indexSetPageSlide(slides.length - 1); };&#10;    keyCodeDict[INDEX_MODE][ENTER_KEY] = function() { return toggleSlideIndex(); };&#10;&#10;    keyCodeDict[DRAWING_MODE][ESCAPE_KEY] = function () { return drawingSwitchToSlideMode(); };&#10;&#10;    return keyCodeDict;&#10;}&#10;&#10;/** Function to handle all mouse events.&#10; *&#10; *    @param    evnt    event&#10; *    @param    action    type of event (e.g. mouse up, mouse wheel)&#10; */&#10;function mouseHandlerDispatch(evnt, action)&#10;{&#10;    if (!evnt)&#10;        evnt = window.event;&#10;&#10;    var retVal = true;&#10;&#10;    if (!processingEffect &amp;&amp; mouseHandlerDictionary[currentMode] &amp;&amp; mouseHandlerDictionary[currentMode][action])&#10;    {&#10;        var subRetVal = mouseHandlerDictionary[currentMode][action](evnt);&#10;&#10;        if (subRetVal != null &amp;&amp; subRetVal != undefined)&#10;            retVal = subRetVal;&#10;    }&#10;&#10;    if (evnt.preventDefault &amp;&amp; !retVal)&#10;        evnt.preventDefault();&#10;&#10;    evnt.returnValue = retVal;&#10;&#10;    return retVal;&#10;}&#10;&#10;// Set mouse event handler.&#10;document.onmousedown = function(e) { return mouseHandlerDispatch(e, MOUSE_DOWN); };&#10;document.onmouseup = function(e) { return mouseHandlerDispatch(e, MOUSE_UP); };&#10;document.onmousemove = function(e) { return mouseHandlerDispatch(e, MOUSE_MOVE); };&#10;&#10;// Moz&#10;if (window.addEventListener)&#10;{&#10;    window.addEventListener('DOMMouseScroll', function(e) { return mouseHandlerDispatch(e, MOUSE_WHEEL); }, false);&#10;}&#10;&#10;// Opera Safari OK - may not work in IE&#10;window.onmousewheel = function(e) { return mouseHandlerDispatch(e, MOUSE_WHEEL); };&#10;&#10;/** Function to supply the default mouse handler dictionary.&#10; *&#10; * @returns default mouse handler dictionary&#10; */&#10;function getDefaultMouseHandlerDictionary()&#10;{&#10;    var mouseHandlerDict = new Object();&#10;&#10;    mouseHandlerDict[SLIDE_MODE] = new Object();&#10;    mouseHandlerDict[INDEX_MODE] = new Object();&#10;    mouseHandlerDict[DRAWING_MODE] = new Object();&#10;&#10;    mouseHandlerDict[SLIDE_MODE][MOUSE_DOWN] = function(evnt) { return dispatchEffects(1); };&#10;    mouseHandlerDict[SLIDE_MODE][MOUSE_WHEEL] = function(evnt) { return slideMousewheel(evnt); };&#10;&#10;    mouseHandlerDict[INDEX_MODE][MOUSE_DOWN] = function(evnt) { return toggleSlideIndex(); };&#10;&#10;    mouseHandlerDict[DRAWING_MODE][MOUSE_DOWN] = function(evnt) { return drawingMousedown(evnt); };&#10;    mouseHandlerDict[DRAWING_MODE][MOUSE_UP] = function(evnt) { return drawingMouseup(evnt); };&#10;    mouseHandlerDict[DRAWING_MODE][MOUSE_MOVE] = function(evnt) { return drawingMousemove(evnt); };&#10;&#10;    return mouseHandlerDict;&#10;}&#10;&#10;/** Function to switch from slide mode to drawing mode.&#10;*/&#10;function slideSwitchToDrawingMode()&#10;{&#10;    currentMode = DRAWING_MODE;&#10;&#10;    var tempDict;&#10;&#10;    if (ROOT_NODE.hasAttribute(&quot;style&quot;))&#10;        tempDict = propStrToDict(ROOT_NODE.getAttribute(&quot;style&quot;));&#10;    else&#10;        tempDict = new Object();&#10;&#10;    tempDict[&quot;cursor&quot;] = &quot;crosshair&quot;;&#10;    ROOT_NODE.setAttribute(&quot;style&quot;, dictToPropStr(tempDict));&#10;}&#10;&#10;/** Function to switch from drawing mode to slide mode.&#10;*/&#10;function drawingSwitchToSlideMode()&#10;{&#10;    currentMode = SLIDE_MODE;&#10;&#10;    var tempDict;&#10;&#10;    if (ROOT_NODE.hasAttribute(&quot;style&quot;))&#10;        tempDict = propStrToDict(ROOT_NODE.getAttribute(&quot;style&quot;));&#10;    else&#10;        tempDict = new Object();&#10;&#10;    tempDict[&quot;cursor&quot;] = &quot;auto&quot;;&#10;    ROOT_NODE.setAttribute(&quot;style&quot;, dictToPropStr(tempDict));&#10;}&#10;&#10;/** Function to decrease the number of columns in index mode.&#10;*/&#10;function indexDecreaseNumberOfColumns()&#10;{&#10;    if (INDEX_COLUMNS &gt;= 3)&#10;    {&#10;        INDEX_COLUMNS -= 1;&#10;        INDEX_OFFSET = -1&#10;            indexSetPageSlide(activeSlide);&#10;    }&#10;}&#10;&#10;/** Function to increase the number of columns in index mode.&#10;*/&#10;function indexIncreaseNumberOfColumns()&#10;{&#10;    if (INDEX_COLUMNS &lt; 7)&#10;    {&#10;        INDEX_COLUMNS += 1;&#10;        INDEX_OFFSET = -1&#10;            indexSetPageSlide(activeSlide);&#10;    }&#10;}&#10;&#10;/** Function to reset the number of columns in index mode.&#10;*/&#10;function indexResetNumberOfColumns()&#10;{&#10;    if (INDEX_COLUMNS != INDEX_COLUMNS_DEFAULT)&#10;    {&#10;        INDEX_COLUMNS = INDEX_COLUMNS_DEFAULT;&#10;        INDEX_OFFSET = -1&#10;            indexSetPageSlide(activeSlide);&#10;    }&#10;}&#10;&#10;/** Function to reset path width in drawing mode.&#10;*/&#10;function drawingResetPathWidth()&#10;{&#10;    path_width = path_width_default;&#10;    set_path_paint_width();&#10;}&#10;&#10;/** Function to set path width in drawing mode.&#10; *&#10; * @param width new path width&#10; */&#10;function drawingSetPathWidth(width)&#10;{&#10;    path_width = width;&#10;    set_path_paint_width();&#10;}&#10;&#10;/** Function to set path colour in drawing mode.&#10; *&#10; * @param colour new path colour&#10; */&#10;function drawingSetPathColour(colour)&#10;{&#10;    path_colour = colour;&#10;}&#10;&#10;/** Function to query the duration of the presentation from the user in slide mode.&#10;*/&#10;function slideQueryDuration()&#10;{&#10;    var new_duration = prompt(&quot;Length of presentation in minutes?&quot;, timer_duration);&#10;&#10;    if ((new_duration != null) &amp;&amp; (new_duration != ''))&#10;    {&#10;        timer_duration = new_duration;&#10;    }&#10;&#10;    updateTimer();&#10;}&#10;&#10;/** Function to add new slide in slide mode.&#10; *&#10; * @param afterSlide after which slide to insert the new one&#10; */&#10;function slideAddSlide(afterSlide)&#10;{&#10;    addSlide(afterSlide);&#10;    slideSetActiveSlide(afterSlide + 1);&#10;    updateTimer();&#10;}&#10;&#10;/** Function to toggle the visibility of the progress bar in slide mode.&#10;*/&#10;function slideToggleProgressBarVisibility()&#10;{&#10;    if (progress_bar_visible)&#10;    {&#10;        progress_bar_visible = false;&#10;        hideProgressBar();&#10;    }&#10;    else&#10;    {&#10;        progress_bar_visible = true;&#10;        showProgressBar();&#10;    }&#10;}&#10;&#10;/** Function to reset the timer in slide mode.&#10;*/&#10;function slideResetTimer()&#10;{&#10;    timer_start = timer_elapsed;&#10;    updateTimer();&#10;}&#10;&#10;/** Convenience function to pad a string with zero in front up to a certain length.&#10; */&#10;function padString(str, len)&#10;{&#10;    var outStr = str;&#10;&#10;    while (outStr.length &lt; len)&#10;    {&#10;        outStr = '0' + outStr;&#10;    }&#10;&#10;    return outStr;&#10;}&#10;&#10;/** Function to update the export layer.&#10; */&#10;function slideUpdateExportLayer()&#10;{&#10;    // Suspend redraw since we are going to mess with the slides.&#10;    var suspendHandle = ROOT_NODE.suspendRedraw(2000);&#10;&#10;    var tmpActiveSlide = activeSlide;&#10;    var tmpActiveEffect = activeEffect;&#10;    var exportedLayers = new Array();&#10;&#10;    for (var counterSlides = 0; counterSlides &lt; slides.length; counterSlides++)&#10;    {&#10;        var exportNode;&#10;&#10;        setSlideToState(counterSlides, STATE_START);&#10;&#10;        var maxEffect = 0;&#10;&#10;        if (slides[counterSlides].effects)&#10;        {&#10;            maxEffect = slides[counterSlides].effects.length;&#10;        }&#10;&#10;        exportNode = slides[counterSlides].element.cloneNode(true);&#10;        exportNode.setAttributeNS(NSS[&quot;inkscape&quot;], &quot;groupmode&quot;, &quot;layer&quot;);&#10;        exportNode.setAttributeNS(NSS[&quot;inkscape&quot;], &quot;label&quot;, &quot;slide_&quot; + padString((counterSlides + 1).toString(), slides.length.toString().length) + &quot;_effect_&quot; + padString(&quot;0&quot;, maxEffect.toString().length));&#10;&#10;        exportedLayers.push(exportNode);&#10;&#10;        if (slides[counterSlides][&quot;effects&quot;])&#10;        {&#10;            for (var counter = 0; counter &lt; slides[counterSlides][&quot;effects&quot;].length; counter++)&#10;            {&#10;                for (var subCounter = 0; subCounter &lt; slides[counterSlides][&quot;effects&quot;][counter].length; subCounter++)&#10;                {&#10;                    var effect = slides[counterSlides][&quot;effects&quot;][counter][subCounter];&#10;                    if (effect[&quot;effect&quot;] == &quot;fade&quot;)&#10;                        fade(parseInt(effect[&quot;dir&quot;]), effect[&quot;element&quot;], STATE_END, effect[&quot;options&quot;]);&#10;                    else if (effect[&quot;effect&quot;] == &quot;appear&quot;)&#10;                        appear(parseInt(effect[&quot;dir&quot;]), effect[&quot;element&quot;], STATE_END, effect[&quot;options&quot;]);&#10;                    else if (effect[&quot;effect&quot;] == &quot;pop&quot;)&#10;                        pop(parseInt(effect[&quot;dir&quot;]), effect[&quot;element&quot;], STATE_END, effect[&quot;options&quot;]);&#10;                    else if (effect[&quot;effect&quot;] == &quot;view&quot;)&#10;                        view(parseInt(effect[&quot;dir&quot;]), effect[&quot;element&quot;], STATE_END, effect[&quot;options&quot;]);&#10;                }&#10;&#10;                var layerName = &quot;slide_&quot; + padString((counterSlides + 1).toString(), slides.length.toString().length) + &quot;_effect_&quot; + padString((counter + 1).toString(), maxEffect.toString().length);&#10;                exportNode = slides[counterSlides].element.cloneNode(true);&#10;                exportNode.setAttributeNS(NSS[&quot;inkscape&quot;], &quot;groupmode&quot;, &quot;layer&quot;);&#10;                exportNode.setAttributeNS(NSS[&quot;inkscape&quot;], &quot;label&quot;, layerName);&#10;                exportNode.setAttribute(&quot;id&quot;, layerName);&#10;&#10;                exportedLayers.push(exportNode);&#10;            }&#10;        }&#10;    }&#10;&#10;    activeSlide = tmpActiveSlide;&#10;    activeEffect = tmpActiveEffect;&#10;    setSlideToState(activeSlide, activeEffect);&#10;&#10;    // Copy image.&#10;    var newDoc = document.documentElement.cloneNode(true);&#10;&#10;    // Delete viewbox form new imag and set width and height.&#10;    newDoc.removeAttribute('viewbox');&#10;    newDoc.setAttribute('width', WIDTH);&#10;    newDoc.setAttribute('height', HEIGHT);&#10;&#10;    // Delete all layers and script elements.&#10;    var nodesToBeRemoved = new Array();&#10;&#10;    for (var childCounter = 0; childCounter &lt;  newDoc.childNodes.length; childCounter++)&#10;    {&#10;        var child = newDoc.childNodes[childCounter];&#10;&#10;        if (child.nodeType == 1)&#10;        {&#10;            if ((child.nodeName.toUpperCase() == 'G') || (child.nodeName.toUpperCase() == 'SCRIPT'))&#10;            {&#10;                nodesToBeRemoved.push(child);&#10;            }&#10;        }&#10;    }&#10;&#10;    for (var ndCounter = 0; ndCounter &lt; nodesToBeRemoved.length; ndCounter++)&#10;    {&#10;        var nd = nodesToBeRemoved[ndCounter];&#10;&#10;        // Before removing the node, check whether it contains any definitions.&#10;        var defs = nd.getElementsByTagNameNS(NSS[&quot;svg&quot;], &quot;defs&quot;);&#10;&#10;        for (var defsCounter = 0; defsCounter &lt; defs.length; defsCounter++)&#10;        {&#10;            if (defs[defsCounter].id)&#10;            {&#10;                newDoc.appendChild(defs[defsCounter].cloneNode(true));&#10;            }&#10;        }&#10;&#10;        // Remove node.&#10;        nd.parentNode.removeChild(nd);&#10;    }&#10;&#10;    // Set current layer.&#10;    if (exportedLayers[0])&#10;    {&#10;        var namedView;&#10;&#10;        for (var nodeCounter = 0; nodeCounter &lt; newDoc.childNodes.length; nodeCounter++)&#10;        {&#10;            if ((newDoc.childNodes[nodeCounter].nodeType == 1) &amp;&amp; (newDoc.childNodes[nodeCounter].getAttribute('id') == 'base'))&#10;            {&#10;                namedView = newDoc.childNodes[nodeCounter];&#10;            }&#10;        }&#10;&#10;        if (namedView)&#10;        {&#10;            namedView.setAttributeNS(NSS['inkscape'], 'current-layer', exportedLayers[0].getAttributeNS(NSS['inkscape'], 'label'));&#10;        }&#10;    }&#10;&#10;    // Add exported layers.&#10;    while (exportedLayers.length &gt; 0)&#10;    {&#10;        var nd = exportedLayers.pop();&#10;&#10;        nd.setAttribute(&quot;opacity&quot;,1);&#10;        nd.style.display = &quot;inherit&quot;;&#10;&#10;        newDoc.appendChild(nd);&#10;    }&#10;&#10;    // Serialise the new document.&#10;  window.location = 'data:application/svg+xml;base64;charset=utf-8,' + window.btoa(unescape(encodeURIComponent((new XMLSerializer()).serializeToString(newDoc))));&#10;&#10;    // Unsuspend redraw.&#10;    ROOT_NODE.unsuspendRedraw(suspendHandle);&#10;    ROOT_NODE.forceRedraw();&#10;}&#10;&#10;/** Function to undo last drawing operation.&#10;*/&#10;function drawingUndo()&#10;{&#10;    mouse_presentation_path = null;&#10;    mouse_original_path = null;&#10;&#10;    if (history_presentation_elements.length &gt; 0)&#10;    {&#10;        var p = history_presentation_elements.pop();&#10;        var parent = p.parentNode.removeChild(p);&#10;&#10;        p = history_original_elements.pop();&#10;        parent = p.parentNode.removeChild(p);&#10;    }&#10;}&#10;&#10;/** Event handler for mouse down in drawing mode.&#10; *&#10; *  @param e the event&#10; */&#10;function drawingMousedown(e)&#10;{&#10;    var value = 0;&#10;&#10;    if (e.button)&#10;        value = e.button;&#10;    else if (e.which)&#10;        value = e.which;&#10;&#10;    if (value == 1)&#10;    {&#10;        history_counter++;&#10;&#10;        var p = calcCoord(e);&#10;&#10;        mouse_last_x = e.clientX;&#10;        mouse_last_y = e.clientY;&#10;        mouse_original_path = document.createElementNS(NSS[&quot;svg&quot;], &quot;path&quot;);&#10;        mouse_original_path.setAttribute(&quot;stroke&quot;, path_colour);&#10;        mouse_original_path.setAttribute(&quot;stroke-width&quot;, path_paint_width);&#10;        mouse_original_path.setAttribute(&quot;fill&quot;, &quot;none&quot;);&#10;        mouse_original_path.setAttribute(&quot;id&quot;, &quot;path &quot; + Date());&#10;        mouse_original_path.setAttribute(&quot;d&quot;, &quot;M&quot; + p.x + &quot;,&quot; + p.y);&#10;        slides[activeSlide][&quot;original_element&quot;].appendChild(mouse_original_path);&#10;        history_original_elements.push(mouse_original_path);&#10;&#10;        mouse_presentation_path = document.createElementNS(NSS[&quot;svg&quot;], &quot;path&quot;);&#10;        mouse_presentation_path.setAttribute(&quot;stroke&quot;, path_colour);&#10;        mouse_presentation_path.setAttribute(&quot;stroke-width&quot;, path_paint_width);&#10;        mouse_presentation_path.setAttribute(&quot;fill&quot;, &quot;none&quot;);&#10;        mouse_presentation_path.setAttribute(&quot;id&quot;, &quot;path &quot; + Date() + &quot; presentation copy&quot;);&#10;        mouse_presentation_path.setAttribute(&quot;d&quot;, &quot;M&quot; + p.x + &quot;,&quot; + p.y);&#10;&#10;        if (slides[activeSlide][&quot;viewGroup&quot;])&#10;            slides[activeSlide][&quot;viewGroup&quot;].appendChild(mouse_presentation_path);&#10;        else&#10;            slides[activeSlide][&quot;element&quot;].appendChild(mouse_presentation_path);&#10;&#10;        history_presentation_elements.push(mouse_presentation_path);&#10;&#10;        return false;&#10;    }&#10;&#10;    return true;&#10;}&#10;&#10;/** Event handler for mouse up in drawing mode.&#10; *&#10; *  @param e the event&#10; */&#10;function drawingMouseup(e)&#10;{&#10;    if(!e)&#10;        e = window.event;&#10;&#10;    if (mouse_presentation_path != null)&#10;    {&#10;        var p = calcCoord(e);&#10;        var d = mouse_presentation_path.getAttribute(&quot;d&quot;);&#10;        d += &quot; L&quot; + p.x + &quot;,&quot; + p.y;&#10;        mouse_presentation_path.setAttribute(&quot;d&quot;, d);&#10;        mouse_presentation_path = null;&#10;        mouse_original_path.setAttribute(&quot;d&quot;, d);&#10;        mouse_original_path = null;&#10;&#10;        return false;&#10;    }&#10;&#10;    return true;&#10;}&#10;&#10;/** Event handler for mouse move in drawing mode.&#10; *&#10; *  @param e the event&#10; */&#10;function drawingMousemove(e)&#10;{&#10;    if(!e)&#10;        e = window.event;&#10;&#10;    var dist = (mouse_last_x - e.clientX) * (mouse_last_x - e.clientX) + (mouse_last_y - e.clientY) * (mouse_last_y - e.clientY);&#10;&#10;    if (mouse_presentation_path == null)&#10;    {&#10;        return true;&#10;    }&#10;&#10;    if (dist &gt;= mouse_min_dist_sqr)&#10;    {&#10;        var p = calcCoord(e);&#10;        var d = mouse_presentation_path.getAttribute(&quot;d&quot;);&#10;        d += &quot; L&quot; + p.x + &quot;,&quot; + p.y;&#10;        mouse_presentation_path.setAttribute(&quot;d&quot;, d);&#10;        mouse_original_path.setAttribute(&quot;d&quot;, d);&#10;        mouse_last_x = e.clientX;&#10;        mouse_last_y = e.clientY;&#10;    }&#10;&#10;    return false;&#10;}&#10;&#10;/** Event handler for mouse wheel events in slide mode.&#10; *  based on http://adomas.org/javascript-mouse-wheel/&#10; *&#10; *  @param e the event&#10; */&#10;function slideMousewheel(e)&#10;{&#10;    var delta = 0;&#10;&#10;    if (!e)&#10;        e = window.event;&#10;&#10;    if (e.wheelDelta)&#10;    { // IE Opera&#10;        delta = e.wheelDelta/120;&#10;    }&#10;    else if (e.detail)&#10;    { // MOZ&#10;        delta = -e.detail/3;&#10;    }&#10;&#10;    if (delta &gt; 0)&#10;        skipEffects(-1);&#10;    else if (delta &lt; 0)&#10;        skipEffects(1);&#10;&#10;    if (e.preventDefault)&#10;        e.preventDefault();&#10;&#10;    e.returnValue = false;&#10;}&#10;&#10;/** Event handler for mouse wheel events in index mode.&#10; *  based on http://adomas.org/javascript-mouse-wheel/&#10; *&#10; *  @param e the event&#10; */&#10;function indexMousewheel(e)&#10;{&#10;    var delta = 0;&#10;&#10;    if (!e)&#10;        e = window.event;&#10;&#10;    if (e.wheelDelta)&#10;    { // IE Opera&#10;        delta = e.wheelDelta/120;&#10;    }&#10;    else if (e.detail)&#10;    { // MOZ&#10;        delta = -e.detail/3;&#10;    }&#10;&#10;    if (delta &gt; 0)&#10;        indexSetPageSlide(activeSlide - INDEX_COLUMNS * INDEX_COLUMNS);&#10;    else if (delta &lt; 0)&#10;        indexSetPageSlide(activeSlide + INDEX_COLUMNS * INDEX_COLUMNS);&#10;&#10;    if (e.preventDefault)&#10;        e.preventDefault();&#10;&#10;    e.returnValue = false;&#10;}&#10;&#10;/** Function to set the path paint width.&#10;*/&#10;function set_path_paint_width()&#10;{&#10;    var svgPoint1 = document.documentElement.createSVGPoint();&#10;    var svgPoint2 = document.documentElement.createSVGPoint();&#10;&#10;    svgPoint1.x = 0.0;&#10;    svgPoint1.y = 0.0;&#10;    svgPoint2.x = 1.0;&#10;    svgPoint2.y = 0.0;&#10;&#10;    var matrix = slides[activeSlide][&quot;element&quot;].getTransformToElement(ROOT_NODE);&#10;&#10;    if (slides[activeSlide][&quot;viewGroup&quot;])&#10;        matrix = slides[activeSlide][&quot;viewGroup&quot;].getTransformToElement(ROOT_NODE);&#10;&#10;    svgPoint1 = svgPoint1.matrixTransform(matrix);&#10;    svgPoint2 = svgPoint2.matrixTransform(matrix);&#10;&#10;    path_paint_width = path_width / Math.sqrt((svgPoint2.x - svgPoint1.x) * (svgPoint2.x - svgPoint1.x) + (svgPoint2.y - svgPoint1.y) * (svgPoint2.y - svgPoint1.y));&#10;}&#10;&#10;/** The view effect.&#10; *&#10; *  @param dir direction the effect should be played (1 = forwards, -1 = backwards)&#10; *  @param element the element the effect should be applied to&#10; *  @param time the time that has elapsed since the beginning of the effect&#10; *  @param options a dictionary with additional options (e.g. length of the effect); for the view effect the options need to contain the old and the new matrix.&#10; */&#10;function view(dir, element, time, options)&#10;{&#10;    var length = 250;&#10;    var fraction;&#10;&#10;    if (!options[&quot;matrixInitial&quot;])&#10;    {&#10;        var tempString = slides[activeSlide][&quot;viewGroup&quot;].getAttribute(&quot;transform&quot;);&#10;&#10;        if (tempString)&#10;            options[&quot;matrixInitial&quot;] = (new matrixSVG()).fromAttribute(tempString);&#10;        else&#10;            options[&quot;matrixInitial&quot;] = (new matrixSVG()).fromSVGElements(1, 0, 0, 1, 0, 0);&#10;    }&#10;&#10;    if ((time == STATE_END) || (time == STATE_START))&#10;        fraction = 1;&#10;    else&#10;    {&#10;        if (options &amp;&amp; options[&quot;length&quot;])&#10;            length = options[&quot;length&quot;];&#10;&#10;        fraction = time / length;&#10;    }&#10;&#10;    if (dir == 1)&#10;    {&#10;        if (fraction &lt;= 0)&#10;        {&#10;            element.setAttribute(&quot;transform&quot;, options[&quot;matrixInitial&quot;].toAttribute());&#10;        }&#10;        else if (fraction &gt;= 1)&#10;        {&#10;            element.setAttribute(&quot;transform&quot;, options[&quot;matrixNew&quot;].toAttribute());&#10;&#10;            set_path_paint_width();&#10;&#10;            options[&quot;matrixInitial&quot;] = null;&#10;            return true;&#10;        }&#10;        else&#10;        {&#10;            element.setAttribute(&quot;transform&quot;, options[&quot;matrixInitial&quot;].mix(options[&quot;matrixNew&quot;], fraction).toAttribute());&#10;        }&#10;    }&#10;    else if (dir == -1)&#10;    {&#10;        if (fraction &lt;= 0)&#10;        {&#10;            element.setAttribute(&quot;transform&quot;, options[&quot;matrixInitial&quot;].toAttribute());&#10;        }&#10;        else if (fraction &gt;= 1)&#10;        {&#10;            element.setAttribute(&quot;transform&quot;, options[&quot;matrixOld&quot;].toAttribute());&#10;            set_path_paint_width();&#10;&#10;            options[&quot;matrixInitial&quot;] = null;&#10;            return true;&#10;        }&#10;        else&#10;        {&#10;            element.setAttribute(&quot;transform&quot;, options[&quot;matrixInitial&quot;].mix(options[&quot;matrixOld&quot;], fraction).toAttribute());&#10;        }&#10;    }&#10;&#10;    return false;&#10;}&#10;&#10;/** The fade effect.&#10; *&#10; *  @param dir direction the effect should be played (1 = forwards, -1 = backwards)&#10; *  @param element the element the effect should be applied to&#10; *  @param time the time that has elapsed since the beginning of the effect&#10; *  @param options a dictionary with additional options (e.g. length of the effect)&#10; */&#10;function fade(dir, element, time, options)&#10;{&#10;    var length = 250;&#10;    var fraction;&#10;&#10;    if ((time == STATE_END) || (time == STATE_START))&#10;        fraction = 1;&#10;    else&#10;    {&#10;        if (options &amp;&amp; options[&quot;length&quot;])&#10;            length = options[&quot;length&quot;];&#10;&#10;        fraction = time / length;&#10;    }&#10;&#10;    if (dir == 1)&#10;    {&#10;        if (fraction &lt;= 0)&#10;        {&#10;            element.style.display = &quot;none&quot;;&#10;            element.setAttribute(&quot;opacity&quot;, 0);&#10;        }&#10;        else if (fraction &gt;= 1)&#10;        {&#10;            element.style.display = &quot;inherit&quot;;&#10;            element.setAttribute(&quot;opacity&quot;, 1);&#10;            return true;&#10;        }&#10;        else&#10;        {&#10;            element.style.display = &quot;inherit&quot;;&#10;            element.setAttribute(&quot;opacity&quot;, fraction);&#10;        }&#10;    }&#10;    else if (dir == -1)&#10;    {&#10;        if (fraction &lt;= 0)&#10;        {&#10;            element.style.display = &quot;inherit&quot;;&#10;            element.setAttribute(&quot;opacity&quot;, 1);&#10;        }&#10;        else if (fraction &gt;= 1)&#10;        {&#10;            element.setAttribute(&quot;opacity&quot;, 0);&#10;            element.style.display = &quot;none&quot;;&#10;            return true;&#10;        }&#10;        else&#10;        {&#10;            element.style.display = &quot;inherit&quot;;&#10;            element.setAttribute(&quot;opacity&quot;, 1 - fraction);&#10;        }&#10;    }&#10;    return false;&#10;}&#10;&#10;/** The appear effect.&#10; *&#10; *  @param dir direction the effect should be played (1 = forwards, -1 = backwards)&#10; *  @param element the element the effect should be applied to&#10; *  @param time the time that has elapsed since the beginning of the effect&#10; *  @param options a dictionary with additional options (e.g. length of the effect)&#10; */&#10;function appear(dir, element, time, options)&#10;{&#10;    if (dir == 1)&#10;    {&#10;        element.style.display = &quot;inherit&quot;;&#10;        element.setAttribute(&quot;opacity&quot;,1);&#10;    }&#10;    else if (dir == -1)&#10;    {&#10;        element.style.display = &quot;none&quot;;&#10;        element.setAttribute(&quot;opacity&quot;,0);&#10;    }&#10;    return true;&#10;}&#10;&#10;/** The pop effect.&#10; *&#10; *  @param dir direction the effect should be played (1 = forwards, -1 = backwards)&#10; *  @param element the element the effect should be applied to&#10; *  @param time the time that has elapsed since the beginning of the effect&#10; *  @param options a dictionary with additional options (e.g. length of the effect)&#10; */&#10;function pop(dir, element, time, options)&#10;{&#10;    var length = 500;&#10;    var fraction;&#10;&#10;    if ((time == STATE_END) || (time == STATE_START))&#10;        fraction = 1;&#10;    else&#10;    {&#10;        if (options &amp;&amp; options[&quot;length&quot;])&#10;            length = options[&quot;length&quot;];&#10;&#10;        fraction = time / length;&#10;    }&#10;&#10;    if (dir == 1)&#10;    {&#10;        if (fraction &lt;= 0)&#10;        {&#10;            element.setAttribute(&quot;opacity&quot;, 0);&#10;            element.setAttribute(&quot;transform&quot;, &quot;scale(0)&quot;);&#10;            element.style.display = &quot;none&quot;;&#10;        }&#10;        else if (fraction &gt;= 1)&#10;        {&#10;            element.setAttribute(&quot;opacity&quot;, 1);&#10;            element.removeAttribute(&quot;transform&quot;);&#10;            element.style.display = &quot;inherit&quot;;&#10;            return true;&#10;        }&#10;        else&#10;        {&#10;            element.style.display = &quot;inherit&quot;;&#10;            var opacityFraction = fraction * 3;&#10;            if (opacityFraction &gt; 1)&#10;                opacityFraction = 1;&#10;            element.setAttribute(&quot;opacity&quot;, opacityFraction);&#10;            var offsetX = WIDTH * (1.0 - fraction) / 2.0;&#10;            var offsetY = HEIGHT * (1.0 - fraction) / 2.0;&#10;            element.setAttribute(&quot;transform&quot;, &quot;translate(&quot; + offsetX + &quot;,&quot; + offsetY + &quot;) scale(&quot; + fraction + &quot;)&quot;);&#10;        }&#10;    }&#10;    else if (dir == -1)&#10;    {&#10;        if (fraction &lt;= 0)&#10;        {&#10;            element.setAttribute(&quot;opacity&quot;, 1);&#10;            element.setAttribute(&quot;transform&quot;, &quot;scale(1)&quot;);&#10;            element.style.display = &quot;inherit&quot;;&#10;        }&#10;        else if (fraction &gt;= 1)&#10;        {&#10;            element.setAttribute(&quot;opacity&quot;, 0);&#10;            element.removeAttribute(&quot;transform&quot;);&#10;            element.style.display = &quot;none&quot;;&#10;            return true;&#10;        }&#10;        else&#10;        {&#10;            element.setAttribute(&quot;opacity&quot;, 1 - fraction);&#10;            element.setAttribute(&quot;transform&quot;, &quot;scale(&quot; + 1 - fraction + &quot;)&quot;);&#10;            element.style.display = &quot;inherit&quot;;&#10;        }&#10;    }&#10;    return false;&#10;}&#10;&#10;/** Function to set a slide either to the start or the end state.&#10; *&#10; *  @param slide the slide to use&#10; *  @param state the state into which the slide should be set&#10; */&#10;function setSlideToState(slide, state)&#10;{&#10;    slides[slide][&quot;viewGroup&quot;].setAttribute(&quot;transform&quot;, slides[slide].initialView);&#10;&#10;    if (slides[slide][&quot;effects&quot;])&#10;    {&#10;        if (state == STATE_END)&#10;        {&#10;            for (var counter = 0; counter &lt; slides[slide][&quot;effects&quot;].length; counter++)&#10;            {&#10;                for (var subCounter = 0; subCounter &lt; slides[slide][&quot;effects&quot;][counter].length; subCounter++)&#10;                {&#10;                    var effect = slides[slide][&quot;effects&quot;][counter][subCounter];&#10;                    if (effect[&quot;effect&quot;] == &quot;fade&quot;)&#10;                        fade(effect[&quot;dir&quot;], effect[&quot;element&quot;], STATE_END, effect[&quot;options&quot;]);&#10;                    else if (effect[&quot;effect&quot;] == &quot;appear&quot;)&#10;                        appear(effect[&quot;dir&quot;], effect[&quot;element&quot;], STATE_END, effect[&quot;options&quot;]);&#10;                    else if (effect[&quot;effect&quot;] == &quot;pop&quot;)&#10;                        pop(effect[&quot;dir&quot;], effect[&quot;element&quot;], STATE_END, effect[&quot;options&quot;]);&#10;                    else if (effect[&quot;effect&quot;] == &quot;view&quot;)&#10;                        view(effect[&quot;dir&quot;], effect[&quot;element&quot;], STATE_END, effect[&quot;options&quot;]);&#10;                }&#10;            }&#10;        }&#10;        else if (state == STATE_START)&#10;        {&#10;            for (var counter = slides[slide][&quot;effects&quot;].length - 1; counter &gt;= 0; counter--)&#10;            {&#10;                for (var subCounter = 0; subCounter &lt; slides[slide][&quot;effects&quot;][counter].length; subCounter++)&#10;                {&#10;                    var effect = slides[slide][&quot;effects&quot;][counter][subCounter];&#10;                    if (effect[&quot;effect&quot;] == &quot;fade&quot;)&#10;                        fade(parseInt(effect[&quot;dir&quot;]) * -1, effect[&quot;element&quot;], STATE_START, effect[&quot;options&quot;]);&#10;                    else if (effect[&quot;effect&quot;] == &quot;appear&quot;)&#10;                        appear(parseInt(effect[&quot;dir&quot;]) * -1, effect[&quot;element&quot;], STATE_START, effect[&quot;options&quot;]);&#10;                    else if (effect[&quot;effect&quot;] == &quot;pop&quot;)&#10;                        pop(parseInt(effect[&quot;dir&quot;]) * -1, effect[&quot;element&quot;], STATE_START, effect[&quot;options&quot;]);&#10;                    else if (effect[&quot;effect&quot;] == &quot;view&quot;)&#10;                        view(parseInt(effect[&quot;dir&quot;]) * -1, effect[&quot;element&quot;], STATE_START, effect[&quot;options&quot;]);&#10;                }&#10;            }&#10;        }&#10;        else&#10;        {&#10;            setSlideToState(slide, STATE_START);&#10;&#10;            for (var counter = 0; counter &lt; slides[slide][&quot;effects&quot;].length &amp;&amp; counter &lt; state; counter++)&#10;            {&#10;                for (var subCounter = 0; subCounter &lt; slides[slide][&quot;effects&quot;][counter].length; subCounter++)&#10;                {&#10;                    var effect = slides[slide][&quot;effects&quot;][counter][subCounter];&#10;                    if (effect[&quot;effect&quot;] == &quot;fade&quot;)&#10;                        fade(effect[&quot;dir&quot;], effect[&quot;element&quot;], STATE_END, effect[&quot;options&quot;]);&#10;                    else if (effect[&quot;effect&quot;] == &quot;appear&quot;)&#10;                        appear(effect[&quot;dir&quot;], effect[&quot;element&quot;], STATE_END, effect[&quot;options&quot;]);&#10;                    else if (effect[&quot;effect&quot;] == &quot;pop&quot;)&#10;                        pop(effect[&quot;dir&quot;], effect[&quot;element&quot;], STATE_END, effect[&quot;options&quot;]);&#10;                    else if (effect[&quot;effect&quot;] == &quot;view&quot;)&#10;                        view(effect[&quot;dir&quot;], effect[&quot;element&quot;], STATE_END, effect[&quot;options&quot;]);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    window.location.hash = (activeSlide + 1) + '_' + activeEffect;&#10;}&#10;&#10;/** Convenience function to translate a attribute string into a dictionary.&#10; *&#10; *    @param str the attribute string&#10; *  @return a dictionary&#10; *  @see dictToPropStr&#10; */&#10;function propStrToDict(str)&#10;{&#10;    var list = str.split(&quot;;&quot;);&#10;    var obj = new Object();&#10;&#10;    for (var counter = 0; counter &lt; list.length; counter++)&#10;    {&#10;        var subStr = list[counter];&#10;        var subList = subStr.split(&quot;:&quot;);&#10;        if (subList.length == 2)&#10;        {&#10;            obj[subList[0]] = subList[1];&#10;        }&#10;    }&#10;&#10;    return obj;&#10;}&#10;&#10;/** Convenience function to translate a dictionary into a string that can be used as an attribute.&#10; *&#10; *  @param dict the dictionary to convert&#10; *  @return a string that can be used as an attribute&#10; *  @see propStrToDict&#10; */&#10;function dictToPropStr(dict)&#10;{&#10;    var str = &quot;&quot;;&#10;&#10;    for (var key in dict)&#10;    {&#10;        str += key + &quot;:&quot; + dict[key] + &quot;;&quot;;&#10;    }&#10;&#10;    return str;&#10;}&#10;&#10;/** Sub-function to add a suffix to the ids of the node and all its children.&#10; *&#10; *    @param node the node to change&#10; *    @param suffix the suffix to add&#10; *    @param replace dictionary of replaced ids&#10; *  @see suffixNodeIds&#10; */&#10;function suffixNoneIds_sub(node, suffix, replace)&#10;{&#10;    if (node.nodeType == 1)&#10;    {&#10;        if (node.getAttribute(&quot;id&quot;))&#10;        {&#10;            var id = node.getAttribute(&quot;id&quot;)&#10;                replace[&quot;#&quot; + id] = id + suffix;&#10;            node.setAttribute(&quot;id&quot;, id + suffix);&#10;        }&#10;&#10;        if ((node.nodeName == &quot;use&quot;) &amp;&amp; (node.getAttributeNS(NSS[&quot;xlink&quot;], &quot;href&quot;)) &amp;&amp; (replace[node.getAttribute(NSS[&quot;xlink&quot;], &quot;href&quot;)]))&#10;            node.setAttribute(NSS[&quot;xlink&quot;], &quot;href&quot;, node.getAttribute(NSS[&quot;xlink&quot;], &quot;href&quot;) + suffix);&#10;&#10;        if (node.childNodes)&#10;        {&#10;            for (var counter = 0; counter &lt; node.childNodes.length; counter++)&#10;                suffixNoneIds_sub(node.childNodes[counter], suffix, replace);&#10;        }&#10;    }&#10;}&#10;&#10;/** Function to add a suffix to the ids of the node and all its children.&#10; *&#10; *    @param node the node to change&#10; *    @param suffix the suffix to add&#10; *  @return the changed node&#10; *  @see suffixNodeIds_sub&#10; */&#10;function suffixNodeIds(node, suffix)&#10;{&#10;    var replace = new Object();&#10;&#10;    suffixNoneIds_sub(node, suffix, replace);&#10;&#10;    return node;&#10;}&#10;&#10;/** Function to build a progress bar.&#10; *&#10; *  @param parent node to attach the progress bar to&#10; */&#10;function createProgressBar(parent_node)&#10;{&#10;    var g = document.createElementNS(NSS[&quot;svg&quot;], &quot;g&quot;);&#10;    g.setAttribute(&quot;clip-path&quot;, &quot;url(#jessyInkSlideClipPath)&quot;);&#10;    g.setAttribute(&quot;id&quot;, &quot;layer_progress_bar&quot;);&#10;    g.setAttribute(&quot;style&quot;, &quot;display: none;&quot;);&#10;&#10;    var rect_progress_bar = document.createElementNS(NSS[&quot;svg&quot;], &quot;rect&quot;);&#10;    rect_progress_bar.setAttribute(&quot;style&quot;, &quot;marker: none; fill: rgb(128, 128, 128); stroke: none;&quot;);&#10;    rect_progress_bar.setAttribute(&quot;id&quot;, &quot;rect_progress_bar&quot;);&#10;    rect_progress_bar.setAttribute(&quot;x&quot;, 0);&#10;    rect_progress_bar.setAttribute(&quot;y&quot;, 0.99 * HEIGHT);&#10;    rect_progress_bar.setAttribute(&quot;width&quot;, 0);&#10;    rect_progress_bar.setAttribute(&quot;height&quot;, 0.01 * HEIGHT);&#10;    g.appendChild(rect_progress_bar);&#10;&#10;    var circle_timer_indicator = document.createElementNS(NSS[&quot;svg&quot;], &quot;circle&quot;);&#10;    circle_timer_indicator.setAttribute(&quot;style&quot;, &quot;marker: none; fill: rgb(255, 0, 0); stroke: none;&quot;);&#10;    circle_timer_indicator.setAttribute(&quot;id&quot;, &quot;circle_timer_indicator&quot;);&#10;    circle_timer_indicator.setAttribute(&quot;cx&quot;, 0.005 * HEIGHT);&#10;    circle_timer_indicator.setAttribute(&quot;cy&quot;, 0.995 * HEIGHT);&#10;    circle_timer_indicator.setAttribute(&quot;r&quot;, 0.005 * HEIGHT);&#10;    g.appendChild(circle_timer_indicator);&#10;&#10;    parent_node.appendChild(g);&#10;}&#10;&#10;/** Function to hide the progress bar.&#10; *&#10; */&#10;function hideProgressBar()&#10;{&#10;    var progress_bar = document.getElementById(&quot;layer_progress_bar&quot;);&#10;&#10;    if (!progress_bar)&#10;    {&#10;        return;&#10;    }&#10;&#10;    progress_bar.setAttribute(&quot;style&quot;, &quot;display: none;&quot;);&#10;}&#10;&#10;/** Function to show the progress bar.&#10; *&#10; */&#10;function showProgressBar()&#10;{&#10;    var progress_bar = document.getElementById(&quot;layer_progress_bar&quot;);&#10;&#10;    if (!progress_bar)&#10;    {&#10;        return;&#10;    }&#10;&#10;    progress_bar.setAttribute(&quot;style&quot;, &quot;display: inherit;&quot;);&#10;}&#10;&#10;/** Set progress bar value.&#10; *&#10; *    @param value the current slide number&#10; *&#10; */&#10;function setProgressBarValue(value)&#10;{&#10;    var rect_progress_bar = document.getElementById(&quot;rect_progress_bar&quot;);&#10;&#10;    if (!rect_progress_bar)&#10;    {&#10;        return;&#10;    }&#10;&#10;    if (value &lt; 1)&#10;    {&#10;        // First slide, assumed to be the title of the presentation&#10;        var x = 0;&#10;        var w = 0.01 * HEIGHT;&#10;    }&#10;    else if (value &gt;= slides.length - 1)&#10;    {&#10;        // Last slide, assumed to be the end of the presentation&#10;        var x = WIDTH - 0.01 * HEIGHT;&#10;        var w = 0.01 * HEIGHT;&#10;    }&#10;    else&#10;    {&#10;        value -= 1;&#10;        value /= (slides.length - 2);&#10;&#10;        var x = WIDTH * value;&#10;        var w = WIDTH / (slides.length - 2);&#10;    }&#10;&#10;    rect_progress_bar.setAttribute(&quot;x&quot;, x);&#10;    rect_progress_bar.setAttribute(&quot;width&quot;, w);&#10;}&#10;&#10;/** Set time indicator.&#10; *&#10; *    @param value the percentage of time elapse so far between 0.0 and 1.0&#10; *&#10; */&#10;function setTimeIndicatorValue(value)&#10;{&#10;    var circle_timer_indicator = document.getElementById(&quot;circle_timer_indicator&quot;);&#10;&#10;    if (!circle_timer_indicator)&#10;    {&#10;        return;&#10;    }&#10;&#10;    if (value &lt; 0.0)&#10;    {&#10;        value = 0.0;&#10;    }&#10;&#10;    if (value &gt; 1.0)&#10;    {&#10;        value = 1.0;&#10;    }&#10;&#10;    var cx = (WIDTH - 0.01 * HEIGHT) * value + 0.005 * HEIGHT;&#10;    circle_timer_indicator.setAttribute(&quot;cx&quot;, cx);&#10;}&#10;&#10;/** Update timer.&#10; *&#10; */&#10;function updateTimer()&#10;{&#10;    timer_elapsed += 1;&#10;    setTimeIndicatorValue((timer_elapsed - timer_start) / (60 * timer_duration));&#10;}&#10;&#10;/** Convert screen coordinates to document coordinates.&#10; *&#10; *  @param e event with screen coordinates&#10; *&#10; *  @return coordinates in SVG file coordinate system&#10; */&#10;function calcCoord(e)&#10;{&#10;    var svgPoint = document.documentElement.createSVGPoint();&#10;    svgPoint.x = e.clientX + window.pageXOffset;&#10;    svgPoint.y = e.clientY + window.pageYOffset;&#10;&#10;    var matrix = slides[activeSlide][&quot;element&quot;].getScreenCTM();&#10;&#10;    if (slides[activeSlide][&quot;viewGroup&quot;])&#10;        matrix = slides[activeSlide][&quot;viewGroup&quot;].getScreenCTM();&#10;&#10;    svgPoint = svgPoint.matrixTransform(matrix.inverse());&#10;    return svgPoint;&#10;}&#10;&#10;/** Add slide.&#10; *&#10; *    @param after_slide after which slide the new slide should be inserted into the presentation&#10; */&#10;function addSlide(after_slide)&#10;{&#10;    number_of_added_slides++;&#10;&#10;    var g = document.createElementNS(NSS[&quot;svg&quot;], &quot;g&quot;);&#10;    g.setAttribute(&quot;clip-path&quot;, &quot;url(#jessyInkSlideClipPath)&quot;);&#10;    g.setAttribute(&quot;id&quot;, &quot;Whiteboard &quot; + Date() + &quot; presentation copy&quot;);&#10;    g.setAttribute(&quot;style&quot;, &quot;display: none;&quot;);&#10;&#10;    var new_slide = new Object();&#10;    new_slide[&quot;element&quot;] = g;&#10;&#10;    // Set build in transition.&#10;    new_slide[&quot;transitionIn&quot;] = new Object();&#10;    var dict = defaultTransitionInDict;&#10;    new_slide[&quot;transitionIn&quot;][&quot;name&quot;] = dict[&quot;name&quot;];&#10;    new_slide[&quot;transitionIn&quot;][&quot;options&quot;] = new Object();&#10;&#10;    for (key in dict)&#10;        if (key != &quot;name&quot;)&#10;            new_slide[&quot;transitionIn&quot;][&quot;options&quot;][key] = dict[key];&#10;&#10;    // Set build out transition.&#10;    new_slide[&quot;transitionOut&quot;] = new Object();&#10;    dict = defaultTransitionOutDict;&#10;    new_slide[&quot;transitionOut&quot;][&quot;name&quot;] = dict[&quot;name&quot;];&#10;    new_slide[&quot;transitionOut&quot;][&quot;options&quot;] = new Object();&#10;&#10;    for (key in dict)&#10;        if (key != &quot;name&quot;)&#10;            new_slide[&quot;transitionOut&quot;][&quot;options&quot;][key] = dict[key];&#10;&#10;    // Copy master slide content.&#10;    if (masterSlide)&#10;    {&#10;        var clonedNode = suffixNodeIds(masterSlide.cloneNode(true), &quot;_&quot; + Date() + &quot; presentation_copy&quot;);&#10;        clonedNode.removeAttributeNS(NSS[&quot;inkscape&quot;], &quot;groupmode&quot;);&#10;        clonedNode.removeAttributeNS(NSS[&quot;inkscape&quot;], &quot;label&quot;);&#10;        clonedNode.style.display = &quot;inherit&quot;;&#10;&#10;        g.appendChild(clonedNode);&#10;    }&#10;&#10;    // Substitute auto texts.&#10;    substituteAutoTexts(g, &quot;Whiteboard &quot; + number_of_added_slides, &quot;W&quot; + number_of_added_slides, slides.length);&#10;&#10;    g.setAttribute(&quot;onmouseover&quot;, &quot;if ((currentMode == INDEX_MODE) &amp;&amp; ( activeSlide != &quot; + (after_slide + 1) + &quot;)) { indexSetActiveSlide(&quot; + (after_slide + 1) + &quot;); };&quot;);&#10;&#10;    // Create a transform group.&#10;    var transformGroup = document.createElementNS(NSS[&quot;svg&quot;], &quot;g&quot;);&#10;&#10;    // Add content to transform group.&#10;    while (g.firstChild)&#10;        transformGroup.appendChild(g.firstChild);&#10;&#10;    // Transfer the transform attribute from the node to the transform group.&#10;    if (g.getAttribute(&quot;transform&quot;))&#10;    {&#10;        transformGroup.setAttribute(&quot;transform&quot;, g.getAttribute(&quot;transform&quot;));&#10;        g.removeAttribute(&quot;transform&quot;);&#10;    }&#10;&#10;    // Create a view group.&#10;    var viewGroup = document.createElementNS(NSS[&quot;svg&quot;], &quot;g&quot;);&#10;&#10;    viewGroup.appendChild(transformGroup);&#10;    new_slide[&quot;viewGroup&quot;] = g.appendChild(viewGroup);&#10;&#10;    // Insert background.&#10;    if (BACKGROUND_COLOR != null)&#10;    {&#10;        var rectNode = document.createElementNS(NSS[&quot;svg&quot;], &quot;rect&quot;);&#10;&#10;        rectNode.setAttribute(&quot;x&quot;, 0);&#10;        rectNode.setAttribute(&quot;y&quot;, 0);&#10;        rectNode.setAttribute(&quot;width&quot;, WIDTH);&#10;        rectNode.setAttribute(&quot;height&quot;, HEIGHT);&#10;        rectNode.setAttribute(&quot;id&quot;, &quot;jessyInkBackground&quot; + Date());&#10;        rectNode.setAttribute(&quot;fill&quot;, BACKGROUND_COLOR);&#10;&#10;        new_slide[&quot;viewGroup&quot;].insertBefore(rectNode, new_slide[&quot;viewGroup&quot;].firstChild);&#10;    }&#10;&#10;    // Set initial view even if there are no other views.&#10;    var matrixOld = (new matrixSVG()).fromElements(1, 0, 0, 0, 1, 0, 0, 0, 1);&#10;&#10;    new_slide[&quot;viewGroup&quot;].setAttribute(&quot;transform&quot;, matrixOld.toAttribute());&#10;    new_slide.initialView = matrixOld.toAttribute();&#10;&#10;    // Insert slide&#10;    var node = slides[after_slide][&quot;element&quot;];&#10;    var next_node = node.nextSibling;&#10;    var parent_node = node.parentNode;&#10;&#10;    if (next_node)&#10;    {&#10;        parent_node.insertBefore(g, next_node);&#10;    }&#10;    else&#10;    {&#10;        parent_node.appendChild(g);&#10;    }&#10;&#10;    g = document.createElementNS(NSS[&quot;svg&quot;], &quot;g&quot;);&#10;    g.setAttributeNS(NSS[&quot;inkscape&quot;], &quot;groupmode&quot;, &quot;layer&quot;);&#10;    g.setAttributeNS(NSS[&quot;inkscape&quot;], &quot;label&quot;, &quot;Whiteboard &quot; + number_of_added_slides);&#10;    g.setAttribute(&quot;clip-path&quot;, &quot;url(#jessyInkSlideClipPath)&quot;);&#10;    g.setAttribute(&quot;id&quot;, &quot;Whiteboard &quot; + Date());&#10;    g.setAttribute(&quot;style&quot;, &quot;display: none;&quot;);&#10;&#10;    new_slide[&quot;original_element&quot;] = g;&#10;&#10;    node = slides[after_slide][&quot;original_element&quot;];&#10;    next_node = node.nextSibling;&#10;    parent_node = node.parentNode;&#10;&#10;    if (next_node)&#10;    {&#10;        parent_node.insertBefore(g, next_node);&#10;    }&#10;    else&#10;    {&#10;        parent_node.appendChild(g);&#10;    }&#10;&#10;    before_new_slide = slides.slice(0, after_slide + 1);&#10;    after_new_slide = slides.slice(after_slide + 1);&#10;    slides = before_new_slide.concat(new_slide, after_new_slide);&#10;&#10;    //resetting the counter attributes on the slides that follow the new slide...&#10;    for (var counter = after_slide+2; counter &lt; slides.length; counter++)&#10;    {&#10;        slides[counter][&quot;element&quot;].setAttribute(&quot;onmouseover&quot;, &quot;if ((currentMode == INDEX_MODE) &amp;&amp; ( activeSlide != &quot; + counter + &quot;)) { indexSetActiveSlide(&quot; + counter + &quot;); };&quot;);&#10;    }&#10;}&#10;&#10;/** Convenience function to obtain a transformation matrix from a point matrix.&#10; *&#10; *    @param mPoints Point matrix.&#10; *    @return A transformation matrix.&#10; */&#10;function pointMatrixToTransformation(mPoints)&#10;{&#10;    mPointsOld = (new matrixSVG()).fromElements(0, WIDTH, WIDTH, 0, 0, HEIGHT, 1, 1, 1);&#10;&#10;    return mPointsOld.mult(mPoints.inv());&#10;}&#10;&#10;/** Convenience function to obtain a matrix with three corners of a rectangle.&#10; *&#10; *    @param rect an svg rectangle&#10; *    @return a matrixSVG containing three corners of the rectangle&#10; */&#10;function rectToMatrix(rect)&#10;{&#10;    rectWidth = rect.getBBox().width;&#10;    rectHeight = rect.getBBox().height;&#10;    rectX = rect.getBBox().x;&#10;    rectY = rect.getBBox().y;&#10;    rectXcorr = 0;&#10;    rectYcorr = 0;&#10;&#10;    scaleX = WIDTH / rectWidth;&#10;    scaleY = HEIGHT / rectHeight;&#10;&#10;    if (scaleX &gt; scaleY)&#10;    {&#10;        scaleX = scaleY;&#10;        rectXcorr -= (WIDTH / scaleX - rectWidth) / 2;&#10;        rectWidth = WIDTH / scaleX;&#10;    }&#10;    else&#10;    {&#10;        scaleY = scaleX;&#10;        rectYcorr -= (HEIGHT / scaleY - rectHeight) / 2;&#10;        rectHeight = HEIGHT / scaleY;&#10;    }&#10;&#10;    if (rect.transform.baseVal.numberOfItems &lt; 1)&#10;    {&#10;        mRectTrans = (new matrixSVG()).fromElements(1, 0, 0, 0, 1, 0, 0, 0, 1);&#10;    }&#10;    else&#10;    {&#10;        mRectTrans = (new matrixSVG()).fromSVGMatrix(rect.transform.baseVal.consolidate().matrix);&#10;    }&#10;&#10;    newBasePoints = (new matrixSVG()).fromElements(rectX, rectX, rectX, rectY, rectY, rectY, 1, 1, 1);&#10;    newVectors = (new matrixSVG()).fromElements(rectXcorr, rectXcorr + rectWidth, rectXcorr + rectWidth, rectYcorr, rectYcorr, rectYcorr + rectHeight, 0, 0, 0);&#10;&#10;    return mRectTrans.mult(newBasePoints.add(newVectors));&#10;}&#10;&#10;/** Function to handle JessyInk elements.&#10; *&#10; *    @param    node    Element node.&#10; */&#10;function handleElement(node)&#10;{&#10;    if (node.getAttributeNS(NSS['jessyink'], 'element') == 'core.video')&#10;    {&#10;        var url;&#10;        var width;&#10;        var height;&#10;        var x;&#10;        var y;&#10;        var transform;&#10;&#10;        var tspans = node.getElementsByTagNameNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;tspan&quot;);&#10;&#10;        for (var tspanCounter = 0; tspanCounter &lt; tspans.length; tspanCounter++)&#10;        {&#10;            if (tspans[tspanCounter].getAttributeNS(&quot;https://launchpad.net/jessyink&quot;, &quot;video&quot;) == &quot;url&quot;)&#10;            {&#10;                url = tspans[tspanCounter].firstChild.nodeValue;&#10;            }&#10;        }&#10;&#10;        var rects = node.getElementsByTagNameNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;rect&quot;);&#10;&#10;        for (var rectCounter = 0; rectCounter &lt; rects.length; rectCounter++)&#10;        {&#10;            if (rects[rectCounter].getAttributeNS(&quot;https://launchpad.net/jessyink&quot;, &quot;video&quot;) == &quot;rect&quot;)&#10;            {&#10;                x = rects[rectCounter].getAttribute(&quot;x&quot;);&#10;                y = rects[rectCounter].getAttribute(&quot;y&quot;);&#10;                width = rects[rectCounter].getAttribute(&quot;width&quot;);&#10;                height = rects[rectCounter].getAttribute(&quot;height&quot;);&#10;                transform = rects[rectCounter].getAttribute(&quot;transform&quot;);&#10;            }&#10;        }&#10;&#10;        for (var childCounter = 0; childCounter &lt; node.childNodes.length; childCounter++)&#10;        {&#10;            if (node.childNodes[childCounter].nodeType == 1)&#10;            {&#10;                if (node.childNodes[childCounter].style)&#10;                {&#10;                    node.childNodes[childCounter].style.display = 'none';&#10;                }&#10;                else&#10;                {&#10;                    node.childNodes[childCounter].setAttribute(&quot;style&quot;, &quot;display: none;&quot;);&#10;                }&#10;            }&#10;        }&#10;&#10;        var foreignNode = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;foreignObject&quot;);&#10;        foreignNode.setAttribute(&quot;x&quot;, x);&#10;        foreignNode.setAttribute(&quot;y&quot;, y);&#10;        foreignNode.setAttribute(&quot;width&quot;, width);&#10;        foreignNode.setAttribute(&quot;height&quot;, height);&#10;        foreignNode.setAttribute(&quot;transform&quot;, transform);&#10;&#10;        var videoNode = document.createElementNS(&quot;http://www.w3.org/1999/xhtml&quot;, &quot;video&quot;);&#10;        videoNode.setAttribute(&quot;src&quot;, url);&#10;&#10;        foreignNode.appendChild(videoNode);&#10;        node.appendChild(foreignNode);&#10;    }&#10;}&#10;&#10;/** Class processing the location hash.&#10; *&#10; *    @param str location hash&#10; */&#10;function LocationHash(str)&#10;{&#10;    this.slideNumber = 0;&#10;    this.effectNumber = 0;&#10;&#10;    str = str.substr(1, str.length - 1);&#10;&#10;    var parts = str.split('_');&#10;&#10;    // Try to extract slide number.&#10;    if (parts.length &gt;= 1)&#10;    {&#10;        try&#10;        {&#10;            var slideNumber = parseInt(parts[0]);&#10;&#10;            if (!isNaN(slideNumber))&#10;            {&#10;                this.slideNumber = slideNumber - 1;&#10;            }&#10;        }&#10;        catch (e)&#10;        {&#10;        }&#10;    }&#10;&#10;    // Try to extract effect number.&#10;    if (parts.length &gt;= 2)&#10;    {&#10;        try&#10;        {&#10;            var effectNumber = parseInt(parts[1]);&#10;&#10;            if (!isNaN(effectNumber))&#10;            {&#10;                this.effectNumber = effectNumber;&#10;            }&#10;        }&#10;        catch (e)&#10;        {&#10;        }&#10;    }&#10;}&#10;&#10;/** Class representing an svg matrix.&#10;*/&#10;function matrixSVG()&#10;{&#10;    this.e11 = 0; // a&#10;    this.e12 = 0; // c&#10;    this.e13 = 0; // e&#10;    this.e21 = 0; // b&#10;    this.e22 = 0; // d&#10;    this.e23 = 0; // f&#10;    this.e31 = 0;&#10;    this.e32 = 0;&#10;    this.e33 = 0;&#10;}&#10;&#10;/** Constructor function.&#10; *&#10; *    @param a element a (i.e. 1, 1) as described in the svg standard.&#10; *    @param b element b (i.e. 2, 1) as described in the svg standard.&#10; *    @param c element c (i.e. 1, 2) as described in the svg standard.&#10; *    @param d element d (i.e. 2, 2) as described in the svg standard.&#10; *    @param e element e (i.e. 1, 3) as described in the svg standard.&#10; *    @param f element f (i.e. 2, 3) as described in the svg standard.&#10; */&#10;matrixSVG.prototype.fromSVGElements = function(a, b, c, d, e, f)&#10;{&#10;    this.e11 = a;&#10;    this.e12 = c;&#10;    this.e13 = e;&#10;    this.e21 = b;&#10;    this.e22 = d;&#10;    this.e23 = f;&#10;    this.e31 = 0;&#10;    this.e32 = 0;&#10;    this.e33 = 1;&#10;&#10;    return this;&#10;}&#10;&#10;/** Constructor function.&#10; *&#10; *    @param matrix an svg matrix as described in the svg standard.&#10; */&#10;matrixSVG.prototype.fromSVGMatrix = function(m)&#10;{&#10;    this.e11 = m.a;&#10;    this.e12 = m.c;&#10;    this.e13 = m.e;&#10;    this.e21 = m.b;&#10;    this.e22 = m.d;&#10;    this.e23 = m.f;&#10;    this.e31 = 0;&#10;    this.e32 = 0;&#10;    this.e33 = 1;&#10;&#10;    return this;&#10;}&#10;&#10;/** Constructor function.&#10; *&#10; *    @param e11 element 1, 1 of the matrix.&#10; *    @param e12 element 1, 2 of the matrix.&#10; *    @param e13 element 1, 3 of the matrix.&#10; *    @param e21 element 2, 1 of the matrix.&#10; *    @param e22 element 2, 2 of the matrix.&#10; *    @param e23 element 2, 3 of the matrix.&#10; *    @param e31 element 3, 1 of the matrix.&#10; *    @param e32 element 3, 2 of the matrix.&#10; *    @param e33 element 3, 3 of the matrix.&#10; */&#10;matrixSVG.prototype.fromElements = function(e11, e12, e13, e21, e22, e23, e31, e32, e33)&#10;{&#10;    this.e11 = e11;&#10;    this.e12 = e12;&#10;    this.e13 = e13;&#10;    this.e21 = e21;&#10;    this.e22 = e22;&#10;    this.e23 = e23;&#10;    this.e31 = e31;&#10;    this.e32 = e32;&#10;    this.e33 = e33;&#10;&#10;    return this;&#10;}&#10;&#10;/** Constructor function.&#10; *&#10; *    @param attrString string value of the &quot;transform&quot; attribute (currently only &quot;matrix&quot; is accepted)&#10; */&#10;matrixSVG.prototype.fromAttribute = function(attrString)&#10;{&#10;    str = attrString.substr(7, attrString.length - 8);&#10;&#10;    str = str.trim();&#10;&#10;    strArray = str.split(&quot;,&quot;);&#10;&#10;    // Opera does not use commas to separate the values of the matrix, only spaces.&#10;    if (strArray.length != 6)&#10;        strArray = str.split(&quot; &quot;);&#10;&#10;    this.e11 = parseFloat(strArray[0]);&#10;    this.e21 = parseFloat(strArray[1]);&#10;    this.e31 = 0;&#10;    this.e12 = parseFloat(strArray[2]);&#10;    this.e22 = parseFloat(strArray[3]);&#10;    this.e32 = 0;&#10;    this.e13 = parseFloat(strArray[4]);&#10;    this.e23 = parseFloat(strArray[5]);&#10;    this.e33 = 1;&#10;&#10;    return this;&#10;}&#10;&#10;/** Output function&#10; *&#10; *    @return a string that can be used as the &quot;transform&quot; attribute.&#10; */&#10;matrixSVG.prototype.toAttribute = function()&#10;{&#10;    return &quot;matrix(&quot; + this.e11 + &quot;, &quot; + this.e21 + &quot;, &quot; + this.e12 + &quot;, &quot; + this.e22 + &quot;, &quot; + this.e13 + &quot;, &quot; + this.e23 + &quot;)&quot;;&#10;}&#10;&#10;/** Matrix nversion.&#10; *&#10; *    @return the inverse of the matrix&#10; */&#10;matrixSVG.prototype.inv = function()&#10;{&#10;    out = new matrixSVG();&#10;&#10;    det = this.e11 * (this.e33 * this.e22 - this.e32 * this.e23) - this.e21 * (this.e33 * this.e12 - this.e32 * this.e13) + this.e31 * (this.e23 * this.e12 - this.e22 * this.e13);&#10;&#10;    out.e11 =  (this.e33 * this.e22 - this.e32 * this.e23) / det;&#10;    out.e12 = -(this.e33 * this.e12 - this.e32 * this.e13) / det;&#10;    out.e13 =  (this.e23 * this.e12 - this.e22 * this.e13) / det;&#10;    out.e21 = -(this.e33 * this.e21 - this.e31 * this.e23) / det;&#10;    out.e22 =  (this.e33 * this.e11 - this.e31 * this.e13) / det;&#10;    out.e23 = -(this.e23 * this.e11 - this.e21 * this.e13) / det;&#10;    out.e31 =  (this.e32 * this.e21 - this.e31 * this.e22) / det;&#10;    out.e32 = -(this.e32 * this.e11 - this.e31 * this.e12) / det;&#10;    out.e33 =  (this.e22 * this.e11 - this.e21 * this.e12) / det;&#10;&#10;    return out;&#10;}&#10;&#10;/** Matrix multiplication.&#10; *&#10; *    @param op another svg matrix&#10; *    @return this * op&#10; */&#10;matrixSVG.prototype.mult = function(op)&#10;{&#10;    out = new matrixSVG();&#10;&#10;    out.e11 = this.e11 * op.e11 + this.e12 * op.e21 + this.e13 * op.e31;&#10;    out.e12 = this.e11 * op.e12 + this.e12 * op.e22 + this.e13 * op.e32;&#10;    out.e13 = this.e11 * op.e13 + this.e12 * op.e23 + this.e13 * op.e33;&#10;    out.e21 = this.e21 * op.e11 + this.e22 * op.e21 + this.e23 * op.e31;&#10;    out.e22 = this.e21 * op.e12 + this.e22 * op.e22 + this.e23 * op.e32;&#10;    out.e23 = this.e21 * op.e13 + this.e22 * op.e23 + this.e23 * op.e33;&#10;    out.e31 = this.e31 * op.e11 + this.e32 * op.e21 + this.e33 * op.e31;&#10;    out.e32 = this.e31 * op.e12 + this.e32 * op.e22 + this.e33 * op.e32;&#10;    out.e33 = this.e31 * op.e13 + this.e32 * op.e23 + this.e33 * op.e33;&#10;&#10;    return out;&#10;}&#10;&#10;/** Matrix addition.&#10; *&#10; *    @param op another svg matrix&#10; *    @return this + op&#10; */&#10;matrixSVG.prototype.add = function(op)&#10;{&#10;    out = new matrixSVG();&#10;&#10;    out.e11 = this.e11 + op.e11;&#10;    out.e12 = this.e12 + op.e12;&#10;    out.e13 = this.e13 + op.e13;&#10;    out.e21 = this.e21 + op.e21;&#10;    out.e22 = this.e22 + op.e22;&#10;    out.e23 = this.e23 + op.e23;&#10;    out.e31 = this.e31 + op.e31;&#10;    out.e32 = this.e32 + op.e32;&#10;    out.e33 = this.e33 + op.e33;&#10;&#10;    return out;&#10;}&#10;&#10;/** Matrix mixing.&#10; *&#10; *    @param op another svg matrix&#10; *    @parma contribOp contribution of the other matrix (0 &lt;= contribOp &lt;= 1)&#10; *    @return (1 - contribOp) * this + contribOp * op&#10; */&#10;matrixSVG.prototype.mix = function(op, contribOp)&#10;{&#10;    contribThis = 1.0 - contribOp;&#10;    out = new matrixSVG();&#10;&#10;    out.e11 = contribThis * this.e11 + contribOp * op.e11;&#10;    out.e12 = contribThis * this.e12 + contribOp * op.e12;&#10;    out.e13 = contribThis * this.e13 + contribOp * op.e13;&#10;    out.e21 = contribThis * this.e21 + contribOp * op.e21;&#10;    out.e22 = contribThis * this.e22 + contribOp * op.e22;&#10;    out.e23 = contribThis * this.e23 + contribOp * op.e23;&#10;    out.e31 = contribThis * this.e31 + contribOp * op.e31;&#10;    out.e32 = contribThis * this.e32 + contribOp * op.e32;&#10;    out.e33 = contribThis * this.e33 + contribOp * op.e33;&#10;&#10;    return out;&#10;}&#10;&#10;/** Trimming function for strings.&#10;*/&#10;String.prototype.trim = function()&#10;{&#10;    return this.replace(/^\s+|\s+$/g, '');&#10;}&#10;&#10;/** SVGElement.getTransformToElement polyfill */&#10;SVGElement.prototype.getTransformToElement = SVGElement.prototype.getTransformToElement || function(elem) {&#10;    return elem.getScreenCTM().inverse().multiply(this.getScreenCTM());&#10;};&#10;</script>
</svg>
